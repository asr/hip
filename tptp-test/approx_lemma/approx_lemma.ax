%include('nats_lists.ax').

%          
% In Haskell:
%
%   approx (S n) Nil         = Nil
%   approx (S n) (Cons x xs) = Cons x (approx n xs)
%
% In FOL:
%
%   ∀ N      → approx(S(N),Nil)        = Nil
%   ∀ N X Xs → approx(S(N),Cons(X,Xs)) = Cons(X,approx(N,Xs))
%   ∀ N Xs   → (approx(N,Xs)            = Bottom)
%             ∨ ( N = S(pred(N) ∧ Xs = Nil ))
%             ∨ ( N = S(pred(N) ∧ Xs = Cons(head(XS),tail(XS))

fof(approx_case_0,axiom,
        ! [H] : (approx(H,nil) = nil)).

fof(approx_case_1,axiom,
        ! [H,X,Xs] : (approx(H,cons(X,Xs)) = cons(X,app(H,Xs)))).

fof(approx_case_2,axiom,
        ! [H,Xs] : ( (approx(H,Xs) = bottom)
                   | (Xs = nil)
                   | (Xs = cons(head(Xs),tail(Xs))))).

% approximation lemma                   

%fof(approximation_lemma,axiom,
%        ! [XS,YS] :
%          (     (XS = YS)
%            <=> (! [N] : (approx(N,XS) = approx(N,YS))))).

% Induction over N in approximation lemma.
% Notice that the basecase is missing as both sides are trivially bottom.
%fof(approximation_lemma_induction,axiom,
%        ! [Xs,Ys] : (
%            (! [N] : ((approx(N,Xs) = approx(N,Ys)) => (approx(suc(N),Xs) = approx(suc(N),Ys))))
%         => (! [N] : (approx(N,Xs) = approx(N,Ys))))).

% this is trivially true          
%fof(approx_lemma_base_case,conjecture,
%        ! [Xs,Ys] :
%          (approx(zero,Xs) = approx(zero,Ys))).

% there is a pointer to approx                            
%fof(approx_ptr_eq,axiom,
%        ! [N,XS] :
%          (app(app(approx_ptr,N),XS) = approx(N,XS))).

