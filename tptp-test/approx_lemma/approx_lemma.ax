%include('nats_lists.ax').

%          
% In Haskell:
%
%   approx (S n) Nil         = Nil
%   approx (S n) (Cons x xs) = Cons x (approx n xs)
%
% In FOL:
%
%   ∀ N      → approx(S(N),Nil)        = Nil
%   ∀ N X Xs → approx(S(N),Cons(X,Xs)) = Cons(X,approx(N,Xs))
%   ∀ N Xs   → (approx(N,Xs)            = Bottom)
%             ∨ ( N = S(pred(N) ∧ Xs = Nil ))
%             ∨ ( N = S(pred(N) ∧ Xs = Cons(head(XS),tail(XS))

fof(approx_case_0,axiom,
        ! [H,T] : (min(T) => (T != approx(H,c_nil) | T = c_nil))).

fof(approx_case_1,axiom,
        ! [H,T,X,Xs] : (min(T) => (T != approx(H,c_cons(X,Xs)) | T = c_cons(X,app(H,Xs))))).

fof(approx_case_2,axiom,
        ! [H,T,Xs] : ( (min(T) & T = approx(H,Xs)) =>
                   ( min(Xs) &
                     ( T = c_bottom
                     | (Xs = c_nil)
                     | (Xs = c_cons(head(Xs),tail(Xs)))
                     ) ))
).

% approximation lemma                   

%fof(approximation_lemma,axiom,
%        ! [XS,YS] :
%          (     (XS = YS)
%            <=> (! [N] : (approx(N,XS) = approx(N,YS))))).

% Induction over N in approximation lemma.
% Notice that the basecase is missing as both sides are trivially bottom.
%fof(approximation_lemma_induction,axiom,
%        ! [Xs,Ys] : (
%            (! [N] : ((approx(N,Xs) = approx(N,Ys)) => (approx(suc(N),Xs) = approx(suc(N),Ys))))
%         => (! [N] : (approx(N,Xs) = approx(N,Ys))))).

% this is trivially true          
%fof(approx_lemma_base_case,conjecture,
%        ! [Xs,Ys] :
%          (approx(zero,Xs) = approx(zero,Ys))).

% there is a pointer to approx                            
%fof(approx_ptr_eq,axiom,
%        ! [N,XS] :
%          (app(app(approx_ptr,N),XS) = approx(N,XS))).

