
# Map. need to send function pointers to map. It uses app
#
# ∀ F      → map(F,nil) = nil
# ∀ F X Xs → map(F,cons(X,Xs)) = cons(app(F,X),map(F,Xs))
# ∀ F Xs   → map(F,Xs) = Bottom
#           ∨ (Xs = cons(head(Xs),tail(Xs)))
#           ∨ (Xs = nil)

fof(map_case_0,axiom,
        ! [F] : (map(F,nil) = nil)).

fof(map_case_1,axiom,
        ! [F,X,Xs] : (map(F,cons(X,Xs)) = cons(app(F,X),map(F,Xs)))).

fof(map_case_2,axiom,
        ! [F,Xs] : ( (map(N,Xs) = bottom)
                   | (Xs = nil)
                   | (Xs = cons(head(Xs),tail(Xs))))).

# There is a ptr to map                   
fof(map_ptr_eq,axiom,
        ! [F,XS] :
          (app(app(map_ptr,F),XS) = map(F,XS))).


# Eprover manages to show:
# map succ [] = []          
# fof(map_suc_nil,conjecture,map(suc_ptr,nil) = nil).
###########

# Eprover manages to show:
# map succ [0] = [1]
#include('nats_lists.ax').
#fof(tmap_suc_singleton,conjecture,
#          map(suc_ptr,cons(zero,nil))
#        = cons(suc(zero),nil)).
############

# Iterate, send funptrs
#
# ∀ F X → iterate(F,X) = cons(X,iterate(F,app(F,X)))
#
# iterate is not strict in any argument!!

fof(iterate_case_0,axiom,
        ! [F,X] : (iterate(F,X) = cons(X,iterate(F,app(F,X))))).

# there is a ptr to iterate        
fof(iterate_ptr_eq,axiom,
        ! [F,X] :
          (app(app(iterate_ptr,F),X) = iterate(F,X))).

# Eprover manages to show
# ∀ n . map succ (iterate succ n) = iterate succ (succ n)
#include('nats_lists.ax').
#include('approx_lemma.ax').
#
#fof(map_iterate_property_for_suc_ptr,conjecture,
#        ! [N] : (map(suc_ptr,iterate(suc_ptr,X)) = iterate(suc_ptr,app(suc_ptr,X)))).
##############

# Eprover manages to show
# ∀ f x . map f (iterate f x) = iterate f (f x)
include('nats_lists.ax').
include('approx_lemma.ax').

fof(map_iterate_property,conjecture,
        ! [F,X] : (map(F,iterate(F,X)) = iterate(F,app(F,X)))).


