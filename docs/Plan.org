#+TITLE:     Time Plan
#+AUTHOR:    Dan Ros√©n
#+EMAIL:     danr@student.gu.se
#+OPTIONS:   H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:nil pri:nil tags:not-in-toc
#+LATEX_HEADER: \usepackage{fullpage,listings,courier}

\lstdefinestyle{numbers}{numberstyle=\tiny}
\lstset{basicstyle=\ttfamily}
\lstset{showstringspaces=false}
\lstloadlanguages{haskell,tptp}

* Github repo
[[http://github.com/danr/autospec/][Link to the github repository.]]

* Week 44 (31 Oct - 6 Nov)
** DONE Write project proposal
** DONE Hand in project proposal
CLOSED: [2011-11-04 Fri 11:45] SCHEDULED: <2011-11-01 Tue>

*** DONE Mail Graham
CLOSED: [2011-11-02 Wed 08:50]
** DONE Write time plan
CLOSED: [2011-11-01 Tue 17:17] SCHEDULED: <2011-11-01 Tue>

** DONE Mail Koen
CLOSED: [2011-11-01 Tue 17:00]
SCHEDULED: <2011-11-01 Tue>
About time plan, merge-sort implementation, approx lemma and
typeclasses.

** TODO Write more examples
SCHEDULED: <2011-11-02 Wed>
*** DONE Add merge sort
CLOSED: [2011-11-02 Wed 10:22]
*** TODO Feldspar examples
*** TODO Case-Analysis from Moa's project
[[http://dream.inf.ed.ac.uk/projects/lemmadiscovery/case_results.php][Case-Analysis Results]]
**** TODO Translate to Haskell
**** TODO Translate Theorems to Haskell
** TODO Comparison with Zeno
*** DONE Write how Zeno compares to this project
CLOSED: [2011-11-02 Wed 10:42]
*** TODO How does Zeno handle typeclasses?
SCHEDULED: <2011-11-02 Wed>

** TODO Haskell $\rightarrow$ Core
The translation should cover most of the examples
SCHEDULED: <2011-11-05 Sat>
*** DONE Lambdas
CLOSED: [2011-11-05 Sat 14:04]
**** TODO More tests needed
*** DONE Sections
CLOSED: [2011-11-05 Sat 15:41]
*** DONE Add all functions in scope for mutually recursive let/where
CLOSED: [2011-11-05 Sat 15:21]
*** TODO Output declarations together with its definitions
Accompany a function with its produced floated definitions
*** DONE Support for pattern matching on lists
CLOSED: [2011-11-05 Sat 12:45]
*** DONE Don't recalculate FV for binds
CLOSED: [2011-11-05 Sat 15:21]
Currently, when something needs to be floated uses a where-clause, the
FV looks inside the definition of the where's definition. This could
be stored to avoid recalulation and to avoid termination issues.
*** TODO Tidy up code and comment
*** TODO Generate code and test
*** TODO Pattern binds
#+BEGIN_SRC haskell
(x,y) = e
#+END_SRC
Here, x and y can occur in e. This can be translated with
#+BEGIN_SRC haskell
e' x y = e
x = case e' x y of (x,y) -> x
y = case e' x y of (x,y) -> y
#+END_SRC
In a let/where stmt there can of course be more free variables in e.
*** Future plans:
Just a reminder what is not currently subject for translation
**** List comprehensions
**** Do notation
**** Let in guards
**** Typeclasses
**** Records
**** As-patterns, and
** TODO Read about different proving techniques

* Week 45 (7 Nov - 13 Nov)
** DONE Meeting with Koen
CLOSED: [2011-11-07 Mon 14:50]
Discuss different proving techniques

Present Haskell $\rightarrow$ Core translation
SCHEDULED: <2011-11-07 Mon>
** TODO Write report about translation to FOL
SCHEDULED: <2011-11-08 Tue>
** TODO Implement proving techniques
*** First steps:
Total and finite input

Later versions can use QuickCheck to see if it holds for partial
input, see paper by NAD et al Chasing Bottoms, and prove with the
given information and prove with finite, infinite, partial and total.

Implement simple proof techniques: approximation lemma, structural
induction, fixpoint induction and [[http://www-formal.stanford.edu/jmc/basis1/node11.html][recursion induction]]
SCHEDULED: <2011-11-11 Fri>

*** Remove unnecessary definitions when proving
Eprover gets totally lost when you have unnecessary axioms in scope.
These needs to be disabled somehow. Probably not predicates, easy to
get inconsistencies with a definition being activated and decativated.
But for each thing you want to prove, one will need to know every
function and datatype it depends on.
**** TODO Disable generation of unneccessary haskell-builtin datatypes
Tuples, lists
** DONE Cabal project file
CLOSED: [2011-11-08 Tue 16:59]
* Week 46 (14 Nov - 20 Nov)
** DONE Meeting with Koen
CLOSED: [2011-11-14 Mon 14:49]

Induction by well-ordering

Induction by negation
$$P(Empty) \rightarrow P(left(a)) \wedge P(right(a))$$
$$\neg P(a)$$

For admissible P:
$$P(\bot) , P(0) , (\forall i . P(i) \rightarrow P(i^+)) \rightarrow$$
$$\forall i \in \mathbb{N}^{finite}_{\bot} . P(i)$$
Meta-theorem from Domain theory gives:
$$\forall i \in \mathbb{N}_{\bot} . P(i)$$

By negation:
$$P(0) \wedge P(\bot) \rightarrow P(pred(a))$$


Termination by well-ordering!

** DONE Bug Sven until registered on course
Suzanna is handling the registration, and should be done soon.
CLOSED: [2011-11-16 Wed 08:50] SCHEDULED: <2011-11-15 Tue>

** DONE Evaluate translation
CLOSED: [2011-11-14 Mon 14:55]
Do we need to add a larger part in the Haskell $\rightarrow$ Core
translation?

Answer : No, but types were added last week and that was
a bit unplanned

** Continued work on proving
SCHEDULED: <2011-11-15 Tue>

Answer : No, but types were added last week and that was
a bit unplanned

** DONE Update examples with the new
** DONE Proving Work
*** DONE Solve induction by depth problem
*** DONE Add approximation lemma
Either use this using typeclasses or simply add
approxType :: Nat -> Type a -> Type a
to the code
Solved by generating the approximation code. This was really simple.

This could be triggered by

#+BEGIN_SRC haskell
prop_map_iterate :: (a -> a) -> a -> Prop (Approx (List a))
prop_map_iterate f x = prove (map f (iterate f x) :=: iterate f (f x))
#+END_SRC

where type Approx a = a or some equivalent. Maybe it isn't necessary
to add: no types are concrete so you only option is to use
approximation lemma.
*** DONE Make an own timeout and able user to specify timeout
*** DONE Run proofs in different threads
Still some work to do here: this only sparks thread for a single
proof technique (approx lemma

* Week 47 (21 Nov - 27 Nov)
** DONE Prepare meeting with Koen
CLOSED: [2011-11-21 Mon 15:16]
*** Last week's work:
**** Depth machine on natural numbers
**** Examples were updated
**** Proofs in different threads
**** Updated argument handling
**** Remove unnecessary definitions when proving
**** Approximation lemma
*** Questions:
**** How to do induction on several variables easy
**** How to do induction on more advanced datatypes than Nat in more than one depth
**** How to handle fixpoint induction easily
**** Where can I get more examples from?
**** I need to work on other things this week (NWERC (wee!), Domain Theory)
**** Still haven't done any report... Take a minor break from coding and do mainly reporting this week?
** DONE Meeting with Koen
*** Approximation lemma solution
Don't introduce a new pointer name, rather introduce a new function
with arity 1. Approximation lemma for lists then becomes:

#+BEGIN_SRC haskell
approx([]) = []
approx(x:xs) = x : h xs
#+END_SRC

Hypothesis: axiom , h lhs = h rhs
Step: conjecture , approx lhs = approx rhs

Futhermore, it is possible to inline the whole definition of approx
instead of treating this as a function.
*** Negated induction nat machine
#+BEGIN_SRC tptp
~P(a)
a = zero | P(pred(a))
a = zero | a = succ(zero) | P(pred(pred(a))
% ^ P(pred(a)) comes from above if a = succ(zero)
#+END_SRC

...

#+BEGIN_SRC tptp
~P(a)
Q(x,y)    => a = x    | Q(succ(x),pred(y))
Q(zero,y) => a = zero | P(pred(y))
Q(zero,a)
#+END_SRC

(I think I remember correctly)
However, this is pretty difficult to generalize to datatypes with

*** Fixpoint induction solution
plus (S n) m = S (plus n m)

then rewrite plus with a newly created plus' with arity 2 like this:

plus (S n) m = S (plus' n m)

Then in order to prove some P which uses plus:

P(bottom) & (P(plus') => P(plus))
*** More examples needed
**** More interesting recursion
**** Using the nice pattern-matching compiler
**** Weird datatypes
Like the domain for lambda calculus:

#+BEGIN_SRC haskell
data D = Fun (D -> D) | Bottom
compile :: Expr -> D
#+END_SRC
*** Lexicographic induction
$(x,y) \le (x',y')$ iff $x \le x' \vee (x = x' & y \le y')$

This does not give a normal "induction matrix", but these proof
obligations:

#+BEGIN_SRC tptp
P(zero)
![y,y'] : P(x,y) => P(suc(x),y')      or y == y'?
![x] : P(x,y) => P(x,suc(y))
#+END_SRC

Um, is this right? I'm a bit confused now.
*** Symmetric induction for commutativity
#+BEGIN_SRC tptp
P(zero,zero)
P(m,zero) => P(suc(m),zero)
P(zero,n) => P(zero,suc(n))
P(m,n) & P(suc(m),n) & P(m,suc(n)) => P(suc(m),suc(n))
#+END_SRC

For trees data T = T * T | L the two * case is:
#+BEGIN_SRC tptp
axioms: P(a,c)
        P(a,d)
        P(b,c)
        P(b,d)
        P(a*b,c)
        P(a*b,d)
        P(a,c*d)
        P(b,c*d)
negated_conjecture: ~ P(a*b,c*d)
#+END_SRC
*** Recursion induction (Plotkin)
To prove x + y = y + x try to prove it with +~ defined as

+~ = flip +

From the equations for + we get this to prove:

zero  +~ y = y , ie, y + zero = y

suc x +~ y = suc (x +~ y), ie, y + suc x = suc (y + x),

which is exactly the movesuc lemma. And if these two are proved (by
induction) we get by Recursion Induction that x + y = y + x. Nice!
*** Try vampire prover
Koen also talked about the author of Prover9 and the memory ceremony
for him and his work on Otter.
*** Agda in the report
It is nice to say that Agda was used to verify that some things were
provable before implementing proof techniques. Like the proof for plus
commmutativity without lemma.
*** Make and remove user specifications of tecniques
Figure out a way for the user to specify which proving techniques she
would like to use. But these should always be optional and if none are
supplied, all applicable techniques should be tried.
*** Stats of which proof techniques could solve which problems
*** Work on NWERC problems!
** Proving work
*** DONE Make threading work correctly
CLOSED: [2011-12-02 Fri 17:00]
*** DONE Smarter handling if bottom cannot be proved
CLOSED: [2011-12-02 Fri 17:00]
Simple induction can answer if it was able to prove the bottom case or
not.
*** TODO Tell the prover how long time it will have.
Koen said that this is important for vampire, does eprover have the
same functionality?

Eprover has --cpu-limit and --soft-cpu-limit that with arguments
in seconds. Cpu-limit only terminates the program, and soft cpu limit
prints out unprocesses clauses. This could or could not give a hint
on where the prover got stuck.
*** TODO Simple induction on several variables
Combine this with the auto-depth problem. This would be nice
*** DONE Approximation lemma with "skolem functions"
CLOSED: [2011-11-21 Mon 15:50]
*** DONE Fixpoint induction
CLOSED: [2011-11-22 Tue 17:20]
To prove P(f) = ! [xs] : lhs(f) = rhs(f):

Prove P(bottom_n) where bottom_n is a function with same arity as f
defined as bottom_n(..) = bottom.

If f is the function we do fixpoint induction over, defined as

f xs = chi(f,xs) + other definitions which, at a first implementation,
may not call f to make things simple. Then define redefine f as:

f xs = chi(f',xs)  where f' is fresh and same arity as f.

Then all you need to show is P(f') => P(f).

Machinery needed:
**** Make bottom_n
**** Instantiate P with a function
**** Make f xs = chi(f',xs) from f xs
**** Find all called functions from lhs and rhs to find fixpoint candidates
**** Check if a function is recursive in itself
(otherwise fixpoint induction typically won't work)
*** TODO Add lemmas from previous proofs
For instance *-assoc for nat needs +-assoc for nat. Only
add lemmas if they hold for bottom? Should the user specify
which lemmas it needs to include?
*** TODO Recursive structure of function -> induction principle
A hard problem! Could also be used to show that functions terminate
** Report proving techniques
** Report related work
* Week 48 (28 Nov - 4 Dec)
** DONE Statistics
CLOSED: [2011-12-05 Mon 11:30]
On how many problems were proved, and which techniques succeeded.

** DONE Properties with pointers
CLOSED: [2011-12-03 Sat 17:00]
If you want to show
#+BEGIN_SRC haskell
id = curry . uncurry
#+END_SRC
There will be no proof found. It would be nice if you could add
#+BEGIN_SRC tptp
fof(appbottom,axiom,! [X] : ('ptr.app'('_|_',X) = '_|_')).
fof(extequality,axiom,! [F,G,X] : (('ptr.app'(F,X) = 'ptr.app'(G,X)) => F = G)).
#+END_SRC
But extequality (with or without bottom) leads to inconsistencies.
appbottom in itself does not seem to lead inconsistencies, but it does
not help at this point.

Futhermore, the property is not necessarily true:
#+BEGIN_SRC haskell
Prelude> (uncurry . curry) (\(a,b) -> 1) undefined
1
Prelude> id (\(a,b) -> 1) undefined
 * Exception: Prelude.undefined
Prelude> id (\(~(a,b)) -> 1) undefined
1
#+END_SRC
But with the definitions I had in Functions.hs was more strict
definitions of uncurry/curry:
#+BEGIN_SRC haskell
Functions Prelude> (uncurry . curry) (\(a,b) -> 1) undefined
*Exception: Prelude.undefined
Functions Prelude> (uncurry . curry) (\(~(a,b)) -> 1) undefined
*Exception: Prelude.undefined
*Functions Prelude> id (\(~(a,b)) -> 1) undefined
1
#+END_SRC

Is this a better definition of extensional equality?
#+BEGIN_SRC tptp
fof(exteq,axiom,! [F,G]: ( (! [X] : (app(F,X) = app(G,X))) => F = G)).
#+END_SRC
Probably :)

* Week 49 (5 Dec - 11 Dec)
** Meeting with Koen
*** Recursion-induction
if f is defined as F(f'), and g=G(g'), then if we prove that
g=F(g'), then we know that F(f') <= F(g'). If both g and and f
terminate, then <= is an equivalence. So this only works for
terminating propertes. We need some way to flag terminating functions.

It is also not really sure what it means for a Haskell function to
terminate. We could have that a function terminates for all finite
input, as then map terminates, but also take n terminates for all
finite n, regardless of size of the input list. So it is not
completely obvious what it means to be a terminating Haskell function.
*** Induction over (f : A -> B) -> P f
Let's say we want to prove $P(f)$ where
$f : \mathbb{N} \rightarrow \mathbb{N}$.

To show
$$\forall f.P(f)$$
then we can do
$$\forall n.\forall f : \mathbb{N} \rightarrow
                        \mathbb{N} \cap {0..n}$$
If P is admissible.

To by induction, maybe we can do (Koen)
#+BEGIN_SRC haskell
P(\x -> 0)

P(f) => P(\x.if x == a then S (f x) else f x)
#+END_SRC
i.e we raise it at one exclusive point.
*** Extensional equality and seq
With seq it is possible to distinguish these two functions:
#+BEGIN_SRC haskell
f = bottom
g = \x -> bottom
#+END_SRC
by doing this
#+BEGIN_SRC haskell
f `seq` () = bottom
g `seq` () = ()
#+END_SRC
But seq is the only function that can do this. We can use extensional
equality and Prop (a -> b) ~= a -> Prop b if restrict ourselves to
Haskell without seq. Alternatively, this could be done with a flag,
--enable-seq, that prevenst Prop (a -> b) => a -> Prop b and
extensional equality.
*** Irrefutable patterns
#+BEGIN_SRC haskell
fst (x,y) = x
snd (x,y) = y
uncurry1 f t      = f (fst t) (snd t)
uncurry2 f (x,y)  = f x y
uncurry3 f ~(x,y) = f x y
#+END_SRC
Here, uncurry1 and uncurry3 are equal, but uncurry2 is too strict.

** DONE Make Prop testable.
CLOSED: [2011-12-05 Mon 15:45]
Also put this in some AutoPrelude. Then we can remove prove,
and just make =:= be the function.
** DONE Add disproving
CLOSED: [2011-12-05 Mon 15:45]
=/= could do for that.
** DONE Fixpoint induction on all subsets of recursive functions
CLOSED: [2011-12-12 Mon 12:33]
prove (x + y == y + x)

** TODO Fixpoint induction for terminating programs
Koen's conjecture is if f is a termiatring program, then lfp f = gfp f
and we have the following rule

$$
\exists a . a \le fix f \rightarrow P(a)
\, \wegde \,
P(x) \rightarrow P(f x)
$$
$$ \Rightarrow P(fix f) $$

Then it holds for finite, total values.

Let the user specify when a function is terminating for sure, by some
notation:
#+BEGIN_SRC haskell
terminates = (+)
#+END_SRC haskell

** DONE Fixpoint induction on different functions
CLOSED: [2011-12-12 Mon 12:33]
$$P(\bot,\bot) \, \wedge \, P(x,y) \rightarrow P(f x,f y)$$
$$ \Rightarrow P(fix f,fix g)$$
Notice that the two $\bot$ can be of different arity

** DONE Induction in several variables, and in more depth
CLOSED: [2011-12-12 Mon 12:33]
This should also fire the definition of integers (data Z = P Nat | N Nat)

** TODO Examples
*** TODO Hinze's last papers about coinduction
A lot of interesting stuff in his papers
*** TODO Dixon's PhD thesis
Nat and Ordinals with exponentials

A noticeable difference with my work and this is Dixon combines
finding lemmas (by rippling for instance) and the way to prove
them. (Or so it seems) The advantage of our approach is that we do not
need to worry HOW to prove something, the ATP will take care of that,
only WHAT to prove.
*** TODO Moa's paper "Conjecture Synthesis for Inductive Theories"
*** DONE Examples from Critics
CLOSED: [2011-12-05 Mon 23:26]
*** TODO Examples with postulated sorting
Postulate < in terms of == True.
#+BEGIN_SRC haskell
postulate : forall x y . x < y == True & y < z == True -> x < y == True
postulate : forall x y . x < y == True -> y < x == False
#+END_SRC haskell
However, Nat has a sorting... I guess we cannot prove that sort sorts
without having lemmas for < <= etc.

** Informal meeting with Koen and Moa
*** Papers to read:
*mumble* Monotonicity by Koen, Ann and Nick
The other paper by Nick and Jasmin
*** Haskell -> Isabel
There is a program called Haskabel that does this. Can our translation
output Isabel? Probably!
*** Finite values
To add finite lemmas there are various ways...
forall x y . Fin(x) & Fin(y) . suc (x + y) = x + suc y
Then we need to have another simple induction scheme
Fin(x) & P(x) => P(suc x)
And more invocations to the prover.
*** Try other provers
Vampire, spass, eprover
*** Computing cluster
I will hopefully get access next week
*** ML
Made to implement Isabel by the module system. Implement a small logic
core in a closed module.
*** Induction on several variables
**** DONE Symmetric induction
CLOSED: [2011-12-12 Mon 12:33]
P(0,0)
P(0,y) => P(0,y+)
P(x,0) => P(x+,0)
P(x,y) & P(x+,y) & P(x,y+) => P(x+,y+)
**** Lexicographic
P(0,0)
P(0,y) => P(0,y+)
(forall y . P(0,y))
(forall y . P(x,y)) => (forall y . (P(x+,y))
* Week 50 (12 Dec - 18 Dec)
** DONE Meeting with Koen
CLOSED: <2011-12-12 Mon 15:00>
*** Translation of implications with guard function
*** Fast and loose reasoning
*** Splitting Haskell's domain in two
** Report
Write the techical part, and all desicions made is put in background
or introduction, and everything not complete put in future work or
discussion.
*** Technical Part
**** Translation to FOL
Describe the core language (a lot design choices there), and
compilation of case expressions in the core language.  Translation
from Haskell to the Core language is pretty straightforward.
**** Describe simple induction and structural induction
**** Fixed point induction
**** Approximation lemma
* Week 51 (19 Dec - 25 Dec)
** Christmas break
SCHEDULED: <2011-12-23 Fri>

* Week 52 (26 Dec - 1 Jan)
** New Year's break
SCHEDULED: <2012-01-01 Sun>

* Week 1 (2 Jan - 8 Jan)
** Write report
SCHEDULED: <2012-01-06 Fri>

** Finite simple induction is not complete
Some properties, like the one in PAP.hs, is indeed a finite theorem
but simple induction cannot show this. It is not a theorem when we
have (+ one). We really need a FIN-predicate, or some other coding.

** Alarming bug with complex patterns
--   If there exists a match-any pattern, we need to add all branches
--   with pattern-matched constructors as bottoms. Though, if the
--   match-any pattern goes to bottom, nothing needs to be done.
--   If there is no match-any pattern, just add a new one which goes to bottom.

This is incorrect, consider:

#+BEGIN_SRC haskell
unbalance :: Tree a -> Tree a
unbalance (Branch (Branch l x r) y r') = unbalance (Branch l x (Branch r y r'))
unbalance (Branch l x r)               = Branch l x (unbalance r)
unbalance Empty                        = Empty
#+END_SRC

Here we need to add (Branch Bottom _ _), but this is not currently
done.  This needs a big overhaul and also some new QC properties which
holds with bottom. Important, important!

*** How to QC this beast

Make some generator (possibly Gen) that creates a function with some
datatype, maybe the standard ones (Nat, Tree, List, Expr), and some
more contrived ones like

#+BEGIN_SRC haskell
data D = A0 | B0 | A1 D | B1 D | A2 D D | B2 D D
#+END_SRC

This function should do some non-trivial pattern matching on this
expression and return in some result data type like

#+BEGIN_SRC haskell
data Res = E0 | E1 | ... | En
#+END_SRC

Furthermore, guards can be added as arguments to the
function. Example:

#+BEGIN_SRC haskell
test :: D -> D -> Bool -> Res
test (A2 B0 x) (B2 (A1 y) z) g0      = E1
test (A2 x B0) (B1 (A1 y))   g0 | g0 = E2
test _         C0            g0      = E3
#+END_SRC

then we generate some values of D and Bool, including bottom, and
monitor the result (in Res or bottom), and then write properties
about it, like this:

#+BEGIN_SRC haskell
prop_test_0 :: Prop Res
prop_test_0 = test (A2 B0 x) (B2 bottom z) True =:= bottom

prop_test_0 :: Prop Res
prop_test_0 = test (A2 B0 A0) (B2 (A1 A0) bottom) bottom =:= E1
#+END_SRC

and see that all properties succeed in autospec, which they should
trivially do by plain/definitional equality.

** Function pointers are really smart.
See the report :) And PAP.hs

* Week 2 (9 Jan - 15 Jan)
** Write report
SCHEDULED: <2012-01-13 Fri>
** Hacking on the lost features
SCHEDULED: <2012-01-13 Fri>

** Problems with pattern coverage
What is the difference between these two definitions?

#+BEGIN_SRC
if' True a b = a
if' _    a b = b

if'' True  a b = a
if'' False a b = b
#+END_SRC

if'' will have that everything but True and False goes to bottom,
and if' will have that everything but True and Bottom goes to b.

Is this OK?
** Equistential quantification in cnf
** DONE Fixed point induction
CLOSED: [2012-01-16 Mon 12:35]
*** DONE Good when you don't have anything to do induction on
CLOSED: [2012-01-13 Fri 13:07]
*** DONE Examples of examples
CLOSED: [2012-01-13 Fri 13:07]
**** map-iterate
**** repeat-iterate
**** append / plus
**** mirror-treeIterate
*** DONE On mutual and subset of occuring functions
CLOSED: [2012-01-13 Fri 13:06]
*** DONE How it was implemented
CLOSED: [2012-01-13 Fri 13:06]
*** DONE Future work: depth machines
CLOSED: [2012-01-16 Mon 12:35]
** DONE Structural induction
CLOSED: [2012-01-16 Mon 12:35]
*** Compare to normal PA induction
*** Chain complete predicates -> infinite properties
*** Structural induction on exponential types
*** Deeper structural induction
*** Future work: induction machines
** DONE Related work
CLOSED: [2012-01-16 Mon 12:34]
*** DONE Coinduction work in Agda by NAD
CLOSED: [2012-01-16 Mon 12:35]
** TODO Future work
*** Properties of implication
**** x + y = x + z -> y = x
needs induction on the whole property, you cannot simply the
antecedent as a lemma
* Week 3 (16 Jan - 22 Jan)

** Good bibtex, bad bibtex
** Hasse diagrams
** Better name than autospec!
** How does the min predicate work
* Week 4 (23 Jan - 29 Jan)
** Prepare presentation
** Final presentation 27th!!!!!
* Week 5 (30 Jan - 5 Feb)
** Report done

