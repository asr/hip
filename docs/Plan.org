#+TITLE:     Time Plan
#+AUTHOR:    Dan Ros√©n
#+EMAIL:     danr@student.gu.se
#+OPTIONS:   H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:nil pri:nil tags:not-in-toc
#+LATEX_HEADER: \usepackage{fullpage}

* Github repo
[[http://github.com/danr/autospec/][Link to the github repository.]]

* Week 44 (31 Oct - 6 Nov)
** DONE Write project proposal
** DONE Hand in project proposal
CLOSED: [2011-11-04 Fri 11:45] SCHEDULED: <2011-11-01 Tue>

*** DONE Mail Graham
CLOSED: [2011-11-02 Wed 08:50]
** DONE Write time plan
CLOSED: [2011-11-01 Tue 17:17] SCHEDULED: <2011-11-01 Tue>

** DONE Mail Koen
CLOSED: [2011-11-01 Tue 17:00]
SCHEDULED: <2011-11-01 Tue>
About time plan, merge-sort implementation, approx lemma and
typeclasses.

** TODO Write more examples
SCHEDULED: <2011-11-02 Wed>
*** DONE Add merge sort
CLOSED: [2011-11-02 Wed 10:22]
*** TODO Feldspar examples
*** TODO Case-Analysis from Moa's project
[[http://dream.inf.ed.ac.uk/projects/lemmadiscovery/case_results.php][Case-Analysis Results]]
**** TODO Translate to Haskell
**** TODO Translate Theorems to Haskell
** TODO Comparison with Zeno
*** DONE Write how Zeno compares to this project
CLOSED: [2011-11-02 Wed 10:42]
*** TODO How does Zeno handle typeclasses?
SCHEDULED: <2011-11-02 Wed>

** TODO Haskell $\rightarrow$ Core
The translation should cover most of the examples
SCHEDULED: <2011-11-05 Sat>
*** DONE Lambdas
CLOSED: [2011-11-05 Sat 14:04]
**** TODO More tests needed
*** DONE Sections
CLOSED: [2011-11-05 Sat 15:41]
*** DONE Add all functions in scope for mutually recursive let/where
CLOSED: [2011-11-05 Sat 15:21]
*** TODO Output declarations together with its definitions
Accompany a function with its produced floated definitions
*** DONE Support for pattern matching on lists
CLOSED: [2011-11-05 Sat 12:45]
*** DONE Don't recalculate FV for binds
CLOSED: [2011-11-05 Sat 15:21]
Currently, when something needs to be floated uses a where-clause, the
FV looks inside the definition of the where's definition. This could
be stored to avoid recalulation and to avoid termination issues.
*** TODO Tidy up code and comment
*** TODO Generate code and test
*** TODO Pattern binds
(x,y) = e
Here, x and y can occur in e. This can be translated with
e' x y = e
x = case e' x y of (x,y) -> x
y = case e' x y of (x,y) -> y
In a let/where stmt there can of course be more free variables in e.
*** Future plans:
Just a reminder what is not currently subject for translation
**** List comprehensions
**** Do notation
**** Let in guards
**** Typeclasses
**** Records
**** As-patterns, and
** TODO Read about different proving techniques

* Week 45 (7 Nov - 13 Nov)
** DONE Meeting with Koen
CLOSED: [2011-11-07 Mon 14:50]
Discuss different proving techniques

Present Haskell $\rightarrow$ Core translation
SCHEDULED: <2011-11-07 Mon>
** TODO Write report about translation to FOL
SCHEDULED: <2011-11-08 Tue>
** TODO Implement proving techniques
*** First steps:
Total and finite input

Later versions can use QuickCheck to see if it holds for partial
input, see paper by NAD et al Chasing Bottoms, and prove with the
given information and prove with finite, infinite, partial and total.

Implement simple proof techniques: approximation lemma, structural
induction, fixpoint induction and [[http://www-formal.stanford.edu/jmc/basis1/node11.html][recursion induction]]
SCHEDULED: <2011-11-11 Fri>

*** Remove unnecessary definitions when proving
Eprover gets totally lost when you have unnecessary axioms in scope.
These needs to be disabled somehow. Probably not predicates, easy to
get inconsistencies with a definition being activated and decativated.
But for each thing you want to prove, one will need to know every
function and datatype it depends on.
**** TODO Disable generation of unneccessary haskell-builtin datatypes
Tuples, lists
** DONE Cabal project file
CLOSED: [2011-11-08 Tue 16:59]
* Week 46 (14 Nov - 20 Nov)
** DONE Meeting with Koen
CLOSED: [2011-11-14 Mon 14:49]

Induction by well-ordering

Induction by negation
$$P(Empty) \rightarrow P(left(a)) \wedge P(right(a))$$
$$\neg P(a)$$

For admissible P:
$$P(\bot) , P(0) , (\forall i . P(i) \rightarrow P(i^+)) \rightarrow$$
$$\forall i \in \mathbb{N}^{finite}_{\bot} . P(i)$$
Meta-theorem from Domain theory gives:
$$\forall i \in \mathbb{N}_{\bot} . P(i)$$

By negation:
$$P(0) \wedge P(\bot) \rightarrow P(pred(a))$$

Termination by well-ordering!

** DONE Bug Sven until registered on course
Suzanna is handling the registration, and should be done soon.
CLOSED: [2011-11-16 Wed 08:50] SCHEDULED: <2011-11-15 Tue>

** DONE Evaluate translation
CLOSED: [2011-11-14 Mon 14:55]
Do we need to add a larger part in the Haskell $\rightarrow$ Core
translation?

Answer : No, but types were added last week and that was
a bit unplanned

** TODO Update examples with the new
** TODO Proving Work
*** TODO Solve induction by depth problem
*** TODO Simple induction on several variables
Combine this with the auto-depth problem. This would be nice
*** TODO Smarter handling if bottom can be proved or not
Simple induction can answer if it was able to prove the bottom case or
not.
*** TODO Make an own timeout and able user to specify timeout
*** TODO Run proofs in different threads
*** TODO Add approximation lemma
Either use this using typeclasses or simply add
approxType :: Nat -> Type a -> Type a
to the code

This could be triggered by

prop_map_iterate :: (a -> a) -> a -> Prop (Approx (List a))
prop_map_iterate f x = prove (map f (iterate f x) :=: iterate f (f x))

where type Approx a = a or some equivalent. Maybe it isn't necessary
to add: no types are concrete so you only option is to use
approximation lemma.
*** TODO Fixpoint induction
*** TODO Add lemmas from previous proofs
For instance *-assoc for nat needs +-assoc for nat. Only
add lemmas if they hold for bottom? Should the user specify
which lemmas it needs to include?
*** TODO Recursive structure of function -> induction principle
A hard problem! Could also be used to show that functions terminate
* Week 47 (21 Nov - 27 Nov)
** Report proving techniques
** Report related work

* Week 48 (28 Nov - 4 Dec)
** Work on proving

* Week 49 (5 Dec - 11 Dec)
** Report work

* Week 50 (12 Dec - 18 Dec)
** First draft of report complete.
Should have all necessary parts.

* Week 51 (19 Dec - 25 Dec)
** Christmas break
SCHEDULED: <2011-12-23 Fri>

* Week 52 (26 Dec - 1 Jan)
** New Year's break
SCHEDULED: <2012-01-01 Sun>

* Week 1 (2 Jan - 8 Jan)
** Write report
SCHEDULED: <2012-01-06 Fri>

* Week 2 (9 Jan - 15 Jan)
** Write report
SCHEDULED: <2012-01-13 Fri>
** Hacking on the lost features
SCHEDULED: <2012-01-13 Fri>

* Week 3 (16 Jan - 22 Jan)
** Write report
SCHEDULED: <2012-01-20 Fri>
** Prepare presentation
SCHEDULED: <2012-01-20 Fri>

* Week 4 (23 Jan - 29 Jan)
** Prepare presentation

** Final presentation

* Week 5 (30 Jan - 5 Feb)
** Report done

