#+TITLE:     Time Plan
#+FILETAGS:  thesis
#+AUTHOR:    Dan Ros√©n
#+EMAIL:     danr@student.gu.se
#+OPTIONS:   H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:nil pri:nil tags:not-in-toc
#+LATEX_HEADER: \usepackage{fullpage,listings,courier}


\lstdefinestyle{numbers}{numberstyle=\tiny}
\lstset{basicstyle=\ttfamily}
\lstset{showstringspaces=false}
\lstloadlanguages{haskell,tptp}

* Deprecated planning
** Github repo
[[http://github.com/danr/autospec/][Link to the github repository.]]
** Week 44 (31 Oct - 6 Nov)
*** DONE Write project proposal
*** DONE Hand in project proposal
CLOSED: [2011-11-04 Fri 11:45] SCHEDULED: <2011-11-01 Tue>

**** DONE Mail Graham
CLOSED: [2011-11-02 Wed 08:50]
*** DONE Write time plan
CLOSED: [2011-11-01 Tue 17:17] SCHEDULED: <2011-11-01 Tue>

*** DONE Mail Koen
CLOSED: [2011-11-01 Tue 17:00]
SCHEDULED: <2011-11-01 Tue>
About time plan, merge-sort implementation, approx lemma and
typeclasses.

*** DONE Write how Zeno compares to this project
CLOSED: [2011-11-02 Wed 10:42]
*** DONE Haskell $\rightarrow$ Core
CLOSED: [2012-01-29 Sun 00:30]
- State "DONE"       from "TODO"       [2012-01-29 Sun 00:30]
The translation should cover most of the examples
SCHEDULED: <2011-11-05 Sat>
**** DONE Lambdas
CLOSED: [2011-11-05 Sat 14:04]
***** TODO More tests needed
**** DONE Sections
CLOSED: [2011-11-05 Sat 15:41]
**** DONE Add all functions in scope for mutually recursive let/where
CLOSED: [2011-11-05 Sat 15:21]
**** DONE Support for pattern matching on lists
CLOSED: [2011-11-05 Sat 12:45]
**** DONE Don't recalculate FV for binds
CLOSED: [2011-11-05 Sat 15:21]
Currently, when something needs to be floated uses a where-clause, the
FV looks inside the definition of the where's definition. This could
be stored to avoid recalulation and to avoid termination issues.
**** SOMEDAY Future Haskell to FOL translation plans:
Just a reminder what is not currently subject for translation
***** List comprehensions
***** Do notation
***** Let in guards
***** Typeclasses
***** Records
***** As-patterns, and
***** Pattern binds
#+BEGIN_SRC haskell
(x,y) = e
#+END_SRC
Here, x and y can occur in e. This can be translated with
#+BEGIN_SRC haskell
e' x y = e
x = case e' x y of (x,y) -> x
y = case e' x y of (x,y) -> y
#+END_SRC
In a let/where stmt there can of course be more free variables in e.
***** Tidy up code and comment
***** Output declarations together with its definitions
Accompany a function with its produced floated definitions
*** DONE Read about different proving techniques
CLOSED: [2012-01-29 Sun 00:30]
- State "DONE"       from "TODO"       [2012-01-29 Sun 00:30]

** Week 45 (7 Nov - 13 Nov)
*** DONE Meeting with Koen
CLOSED: [2011-11-07 Mon 14:50]
Discuss different proving techniques

Present Haskell $\rightarrow$ Core translation
SCHEDULED: <2011-11-07 Mon>
*** Write report about translation to FOL
*** DONE Implement proving techniques
CLOSED: [2012-01-29 Sun 00:33]
- State "DONE"       from "TODO"       [2012-01-29 Sun 00:33]
**** First steps:
Total and finite input

Later versions can use QuickCheck to see if it holds for partial
input, see paper by NAD et al Chasing Bottoms, and prove with the
given information and prove with finite, infinite, partial and total.

Implement simple proof techniques: approximation lemma, structural
induction, fixpoint induction and [[http://www-formal.stanford.edu/jmc/basis1/node11.html][recursion induction]]


**** Remove unnecessary definitions when proving
Eprover gets totally lost when you have unnecessary axioms in scope.
These needs to be disabled somehow. Probably not predicates, easy to
get inconsistencies with a definition being activated and decativated.
But for each thing you want to prove, one will need to know every
function and datatype it depends on.
***** DONE Disable generation of unneccessary haskell-builtin datatypes
CLOSED: [2012-01-29 Sun 00:33]
- State "DONE"       from "TODO"       [2012-01-29 Sun 00:33]
Tuples, lists
*** DONE Cabal project file
CLOSED: [2011-11-08 Tue 16:59]
** Week 46 (14 Nov - 20 Nov)
*** DONE Meeting with Koen
CLOSED: [2011-11-14 Mon 14:49]

Induction by well-ordering

Induction by negation
$$P(Empty) \rightarrow P(left(a)) \wedge P(right(a))$$
$$\neg P(a)$$

For admissible P:
$$P(\bot) , P(0) , (\forall i . P(i) \rightarrow P(i^+)) \rightarrow$$
$$\forall i \in \mathbb{N}^{finite}_{\bot} . P(i)$$
Meta-theorem from Domain theory gives:
$$\forall i \in \mathbb{N}_{\bot} . P(i)$$

By negation:
$$P(0) \wedge P(\bot) \rightarrow P(pred(a))$$


Termination by well-ordering!

*** DONE Bug Sven until registered on course
Suzanna is handling the registration, and should be done soon.
CLOSED: [2011-11-16 Wed 08:50] SCHEDULED: <2011-11-15 Tue>

*** DONE Evaluate translation
CLOSED: [2011-11-14 Mon 14:55]
Do we need to add a larger part in the Haskell $\rightarrow$ Core
translation?

Answer : No, but types were added last week and that was
a bit unplanned

*** Continued work on proving

Answer : No, but types were added last week and that was
a bit unplanned

*** DONE Update examples with the new
*** DONE Proving Work
**** DONE Solve induction by depth problem
**** DONE Add approximation lemma
Either use this using typeclasses or simply add
approxType :: Nat -> Type a -> Type a
to the code
Solved by generating the approximation code. This was really simple.

This could be triggered by

#+BEGIN_SRC haskell
prop_map_iterate :: (a -> a) -> a -> Prop (Approx (List a))
prop_map_iterate f x = prove (map f (iterate f x) :=: iterate f (f x))
#+END_SRC

where type Approx a = a or some equivalent. Maybe it isn't necessary
to add: no types are concrete so you only option is to use
approximation lemma.
**** DONE Make an own timeout and able user to specify timeout
**** DONE Run proofs in different threads
Still some work to do here: this only sparks thread for a single
proof technique (approx lemma

** Week 47 (21 Nov - 27 Nov)
*** DONE Prepare meeting with Koen
CLOSED: [2011-11-21 Mon 15:16]
**** Last week's work:
***** Depth machine on natural numbers
***** Examples were updated
***** Proofs in different threads
***** Updated argument handling
***** Remove unnecessary definitions when proving
***** Approximation lemma
**** Questions:
***** How to do induction on several variables easy
***** How to do induction on more advanced datatypes than Nat in more than one depth
***** How to handle fixpoint induction easily
***** Where can I get more examples from?
***** I need to work on other things this week (NWERC (wee!), Domain Theory)
***** Still haven't done any report... Take a minor break from coding and do mainly reporting this week?
*** DONE Meeting with Koen
**** Approximation lemma solution
Don't introduce a new pointer name, rather introduce a new function
with arity 1. Approximation lemma for lists then becomes:

#+BEGIN_SRC haskell
approx([]) = []
approx(x:xs) = x : h xs
#+END_SRC

Hypothesis: axiom , h lhs = h rhs
Step: conjecture , approx lhs = approx rhs

Futhermore, it is possible to inline the whole definition of approx
instead of treating this as a function.
**** Negated induction nat machine
#+BEGIN_SRC tptp
~P(a)
a = zero | P(pred(a))
a = zero | a = succ(zero) | P(pred(pred(a))
% ^ P(pred(a)) comes from above if a = succ(zero)
#+END_SRC

...

#+BEGIN_SRC tptp
~P(a)
Q(x,y)    => a = x    | Q(succ(x),pred(y))
Q(zero,y) => a = zero | P(pred(y))
Q(zero,a)
#+END_SRC

(I think I remember correctly)
However, this is pretty difficult to generalize to datatypes with

**** Fixpoint induction solution
plus (S n) m = S (plus n m)

then rewrite plus with a newly created plus' with arity 2 like this:

plus (S n) m = S (plus' n m)

Then in order to prove some P which uses plus:

P(bottom) & (P(plus') => P(plus))
**** More examples needed
***** More interesting recursion
***** Using the nice pattern-matching compiler
***** Weird datatypes
Like the domain for lambda calculus:

#+BEGIN_SRC haskell
data D = Fun (D -> D) | Bottom
compile :: Expr -> D
#+END_SRC
**** Lexicographic induction
$(x,y) \le (x',y')$ iff $x \le x' \vee (x = x' & y \le y')$

This does not give a normal "induction matrix", but these proof
obligations:

#+BEGIN_SRC tptp
P(zero)
![y,y'] : P(x,y) => P(suc(x),y')      or y == y'?
![x] : P(x,y) => P(x,suc(y))
#+END_SRC

Um, is this right? I'm a bit confused now.
**** Symmetric induction for commutativity
#+BEGIN_SRC tptp
P(zero,zero)
P(m,zero) => P(suc(m),zero)
P(zero,n) => P(zero,suc(n))
P(m,n) & P(suc(m),n) & P(m,suc(n)) => P(suc(m),suc(n))
#+END_SRC

For trees data T = T * T | L the two * case is:
#+BEGIN_SRC tptp
axioms: P(a,c)
        P(a,d)
        P(b,c)
        P(b,d)
        P(a*b,c)
        P(a*b,d)
        P(a,c*d)
        P(b,c*d)
negated_conjecture: ~ P(a*b,c*d)
#+END_SRC
**** Recursion induction (Plotkin)
To prove x + y = y + x try to prove it with +~ defined as

+~ = flip +

From the equations for + we get this to prove:

zero  +~ y = y , ie, y + zero = y

suc x +~ y = suc (x +~ y), ie, y + suc x = suc (y + x),

which is exactly the movesuc lemma. And if these two are proved (by
induction) we get by Recursion Induction that x + y = y + x. Nice!
**** Try vampire prover
Koen also talked about the author of Prover9 and the memory ceremony
for him and his work on Otter.
**** Agda in the report
It is nice to say that Agda was used to verify that some things were
provable before implementing proof techniques. Like the proof for plus
commmutativity without lemma.
**** Make and remove user specifications of tecniques
Figure out a way for the user to specify which proving techniques she
would like to use. But these should always be optional and if none are
supplied, all applicable techniques should be tried.
**** Stats of which proof techniques could solve which problems
**** Work on NWERC problems!
*** Proving work
**** DONE Make threading work correctly
CLOSED: [2011-12-02 Fri 17:00]
**** DONE Smarter handling if bottom cannot be proved
CLOSED: [2011-12-02 Fri 17:00]
Simple induction can answer if it was able to prove the bottom case or
not.
**** TODO Tell the prover how long time it will have.
Koen said that this is important for vampire, does eprover have the
same functionality?

Eprover has --cpu-limit and --soft-cpu-limit that with arguments
in seconds. Cpu-limit only terminates the program, and soft cpu limit
prints out unprocesses clauses. This could or could not give a hint
on where the prover got stuck.
**** TODO Simple induction on several variables
Combine this with the auto-depth problem. This would be nice
**** DONE Approximation lemma with "skolem functions"
CLOSED: [2011-11-21 Mon 15:50]
**** DONE Fixpoint induction
CLOSED: [2011-11-22 Tue 17:20]
To prove P(f) = ! [xs] : lhs(f) = rhs(f):

Prove P(bottom_n) where bottom_n is a function with same arity as f
defined as bottom_n(..) = bottom.

If f is the function we do fixpoint induction over, defined as

f xs = chi(f,xs) + other definitions which, at a first implementation,
may not call f to make things simple. Then define redefine f as:

f xs = chi(f',xs)  where f' is fresh and same arity as f.

Then all you need to show is P(f') => P(f).

Machinery needed:
***** Make bottom_n
***** Instantiate P with a function
***** Make f xs = chi(f',xs) from f xs
***** Find all called functions from lhs and rhs to find fixpoint candidates
***** Check if a function is recursive in itself
(otherwise fixpoint induction typically won't work)
**** TODO Add lemmas from previous proofs
For instance *-assoc for nat needs +-assoc for nat. Only
add lemmas if they hold for bottom? Should the user specify
which lemmas it needs to include?
**** TODO Recursive structure of function -> induction principle
A hard problem! Could also be used to show that functions terminate
*** Report proving techniques
*** Report related work
** Week 48 (28 Nov - 4 Dec)
*** DONE Statistics
CLOSED: [2011-12-05 Mon 11:30]
On how many problems were proved, and which techniques succeeded.

*** DONE Properties with pointers
CLOSED: [2011-12-03 Sat 17:00]
If you want to show
#+BEGIN_SRC haskell
id = curry . uncurry
#+END_SRC
There will be no proof found. It would be nice if you could add
#+BEGIN_SRC tptp
fof(appbottom,axiom,! [X] : ('ptr.app'('_|_',X) = '_|_')).
fof(extequality,axiom,! [F,G,X] : (('ptr.app'(F,X) = 'ptr.app'(G,X)) => F = G)).
#+END_SRC
But extequality (with or without bottom) leads to inconsistencies.
appbottom in itself does not seem to lead inconsistencies, but it does
not help at this point.

Futhermore, the property is not necessarily true:
#+BEGIN_SRC haskell
Prelude> (uncurry . curry) (\(a,b) -> 1) undefined
1
Prelude> id (\(a,b) -> 1) undefined
 * Exception: Prelude.undefined
Prelude> id (\(~(a,b)) -> 1) undefined
1
#+END_SRC
But with the definitions I had in Functions.hs was more strict
definitions of uncurry/curry:
#+BEGIN_SRC haskell
Functions Prelude> (uncurry . curry) (\(a,b) -> 1) undefined
*Exception: Prelude.undefined
Functions Prelude> (uncurry . curry) (\(~(a,b)) -> 1) undefined
*Exception: Prelude.undefined
*Functions Prelude> id (\(~(a,b)) -> 1) undefined
1
#+END_SRC

Is this a better definition of extensional equality?
#+BEGIN_SRC tptp
fof(exteq,axiom,! [F,G]: ( (! [X] : (app(F,X) = app(G,X))) => F = G)).
#+END_SRC
Probably :)

** Week 49 (5 Dec - 11 Dec)
*** Meeting with Koen
**** Recursion-induction
if f is defined as F(f'), and g=G(g'), then if we prove that
g=F(g'), then we know that F(f') <= F(g'). If both g and and f
terminate, then <= is an equivalence. So this only works for
terminating propertes. We need some way to flag terminating functions.

It is also not really sure what it means for a Haskell function to
terminate. We could have that a function terminates for all finite
input, as then map terminates, but also take n terminates for all
finite n, regardless of size of the input list. So it is not
completely obvious what it means to be a terminating Haskell function.
**** Induction over (f : A -> B) -> P f
Let's say we want to prove $P(f)$ where
$f : \mathbb{N} \rightarrow \mathbb{N}$.

To show
$$\forall f.P(f)$$
then we can do
$$\forall n.\forall f : \mathbb{N} \rightarrow
                        \mathbb{N} \cap {0..n}$$
If P is admissible.

To by induction, maybe we can do (Koen)
#+BEGIN_SRC haskell
P(\x -> 0)

P(f) => P(\x.if x == a then S (f x) else f x)
#+END_SRC
i.e we raise it at one exclusive point.
**** Extensional equality and seq
With seq it is possible to distinguish these two functions:
#+BEGIN_SRC haskell
f = bottom
g = \x -> bottom
#+END_SRC
by doing this
#+BEGIN_SRC haskell
f `seq` () = bottom
g `seq` () = ()
#+END_SRC
But seq is the only function that can do this. We can use extensional
equality and Prop (a -> b) ~= a -> Prop b if restrict ourselves to
Haskell without seq. Alternatively, this could be done with a flag,
--enable-seq, that prevenst Prop (a -> b) => a -> Prop b and
extensional equality.
**** Irrefutable patterns
#+BEGIN_SRC haskell
fst (x,y) = x
snd (x,y) = y
uncurry1 f t      = f (fst t) (snd t)
uncurry2 f (x,y)  = f x y
uncurry3 f ~(x,y) = f x y
#+END_SRC
Here, uncurry1 and uncurry3 are equal, but uncurry2 is too strict.

*** DONE Make Prop testable.
CLOSED: [2011-12-05 Mon 15:45]
Also put this in some AutoPrelude. Then we can remove prove,
and just make =:= be the function.
*** DONE Add disproving
CLOSED: [2011-12-05 Mon 15:45]
=/= could do for that.
*** DONE Fixpoint induction on all subsets of recursive functions
CLOSED: [2011-12-12 Mon 12:33]
prove (x + y == y + x)

*** SOMEDAY Fixpoint induction for terminating programs
Koen's conjecture is if f is a termiatring program, then lfp f = gfp f
and we have the following rule

$$
\exists a . a \le fix f \rightarrow P(a)
\, \wegde \,
P(x) \rightarrow P(f x)
$$
$$ \Rightarrow P(fix f) $$

Then it holds for finite, total values.

Let the user specify when a function is terminating for sure, by some
notation:
#+BEGIN_SRC haskell
terminates = (+)
#+END_SRC haskell

*** DONE Fixpoint induction on different functions
CLOSED: [2011-12-12 Mon 12:33]
$$P(\bot,\bot) \, \wedge \, P(x,y) \rightarrow P(f x,f y)$$
$$ \Rightarrow P(fix f,fix g)$$
Notice that the two $\bot$ can be of different arity

*** DONE Induction in several variables, and in more depth
CLOSED: [2011-12-12 Mon 12:33]
This should also fire the definition of integers (data Z = P Nat | N Nat)

*** Examples
**** SOMEDAY Hinze's last papers about coinduction
A lot of interesting stuff in his papers
**** SOMEDAY Dixon's PhD thesis
Nat and Ordinals with exponentials

A noticeable difference with my work and this is Dixon combines
finding lemmas (by rippling for instance) and the way to prove
them. (Or so it seems) The advantage of our approach is that we do not
need to worry HOW to prove something, the ATP will take care of that,
only WHAT to prove.
**** SOMEDAY Moa's paper "Conjecture Synthesis for Inductive Theories"
**** DONE Examples from Critics
CLOSED: [2011-12-05 Mon 23:26]
**** SOMEDAY Examples with postulated sorting
Postulate < in terms of == True.
#+BEGIN_SRC haskell
postulate : forall x y . x < y == True & y < z == True -> x < y == True
postulate : forall x y . x < y == True -> y < x == False
#+END_SRC haskell
However, Nat has a sorting... I guess we cannot prove that sort sorts
without having lemmas for < <= etc.

*** DONE Informal meeting with Koen and Moa
CLOSED: [2012-01-29 Sun 00:34]
- State "DONE"       from "SOMEDAY"    [2012-01-29 Sun 00:34]
**** Papers to read:
*mumble* Monotonicity by Koen, Ann and Nick
The other paper by Nick and Jasmin
**** Haskell -> Isabel
There is a program called Haskabel that does this. Can our translation
output Isabel? Probably!
**** Finite values
To add finite lemmas there are various ways...
forall x y . Fin(x) & Fin(y) . suc (x + y) = x + suc y
Then we need to have another simple induction scheme
Fin(x) & P(x) => P(suc x)
And more invocations to the prover.
**** Try other provers
Vampire, spass, eprover
**** Computing cluster
I will hopefully get access next week
**** ML
Made to implement Isabel by the module system. Implement a small logic
core in a closed module.
**** Induction on several variables
***** DONE Symmetric induction
CLOSED: [2011-12-12 Mon 12:33]
P(0,0)
P(0,y) => P(0,y+)
P(x,0) => P(x+,0)
P(x,y) & P(x+,y) & P(x,y+) => P(x+,y+)
***** Lexicographic
P(0,0)
P(0,y) => P(0,y+)
(forall y . P(0,y))
(forall y . P(x,y)) => (forall y . (P(x+,y))
** Week 50 (12 Dec - 18 Dec)
*** DONE Meeting with Koen
CLOSED: <2011-12-12 Mon 15:00>
**** Translation of implications with guard function
**** Fast and loose reasoning
**** Splitting Haskell's domain in two
*** Report
Write the techical part, and all desicions made is put in background
or introduction, and everything not complete put in future work or
discussion.
**** Technical Part
***** Translation to FOL
Describe the core language (a lot design choices there), and
compilation of case expressions in the core language.  Translation
from Haskell to the Core language is pretty straightforward.
***** Describe simple induction and structural induction
***** Fixed point induction
***** Approximation lemma
** Week 51 (19 Dec - 25 Dec)
*** DONE Christmas break
CLOSED: [2012-01-29 Sun 00:34] SCHEDULED: <2011-12-23 Fri>
- State "DONE"       from ""           [2012-01-29 Sun 00:34]

** Week 52 (26 Dec - 1 Jan)
*** DONE New Year's break
CLOSED: [2012-01-29 Sun 00:34] SCHEDULED: <2012-01-01 Sun>
- State "DONE"       from ""           [2012-01-29 Sun 00:34]

** Week 1 (2 Jan - 8 Jan)
*** DONE Write report
CLOSED: [2012-01-29 Sun 00:34] SCHEDULED: <2012-01-06 Fri>
- State "DONE"       from ""           [2012-01-29 Sun 00:34]

*** Finite simple induction is not complete
Some properties, like the one in PAP.hs, is indeed a finite theorem
but simple induction cannot show this. It is not a theorem when we
have (+ one). We really need a FIN-predicate, or some other coding.
Is this really true?

*** DONE Alarming bug with complex patterns
CLOSED: [2012-01-29 Sun 00:34]
- State "DONE"       from ""           [2012-01-29 Sun 00:34]
--   If there exists a match-any pattern, we need to add all branches
--   with pattern-matched constructors as bottoms. Though, if the
--   match-any pattern goes to bottom, nothing needs to be done.
--   If there is no match-any pattern, just add a new one which goes to bottom.

This is incorrect, consider:

#+BEGIN_SRC haskell
unbalance :: Tree a -> Tree a
unbalance (Branch (Branch l x r) y r') = unbalance (Branch l x (Branch r y r'))
unbalance (Branch l x r)               = Branch l x (unbalance r)
unbalance Empty                        = Empty
#+END_SRC

Here we need to add (Branch Bottom _ _), but this is not currently
done.  This needs a big overhaul and also some new QC properties which
holds with bottom. Important, important!

**** How to QC this beast

Make some generator (possibly Gen) that creates a function with some
datatype, maybe the standard ones (Nat, Tree, List, Expr), and some
more contrived ones like

#+BEGIN_SRC haskell
data D = A0 | B0 | A1 D | B1 D | A2 D D | B2 D D
#+END_SRC

This function should do some non-trivial pattern matching on this
expression and return in some result data type like

#+BEGIN_SRC haskell
data Res = E0 | E1 | ... | En
#+END_SRC

Furthermore, guards can be added as arguments to the
function. Example:

#+BEGIN_SRC haskell
test :: D -> D -> Bool -> Res
test (A2 B0 x) (B2 (A1 y) z) g0      = E1
test (A2 x B0) (B1 (A1 y))   g0 | g0 = E2
test _         C0            g0      = E3
#+END_SRC

then we generate some values of D and Bool, including bottom, and
monitor the result (in Res or bottom), and then write properties
about it, like this:

#+BEGIN_SRC haskell
prop_test_0 :: Prop Res
prop_test_0 = test (A2 B0 x) (B2 bottom z) True =:= bottom

prop_test_0 :: Prop Res
prop_test_0 = test (A2 B0 A0) (B2 (A1 A0) bottom) bottom =:= E1
#+END_SRC

and see that all properties succeed in autospec, which they should
trivially do by plain/definitional equality.

*** Function pointers are really smart.
See the report :) And PAP.hs

** Week 2 (9 Jan - 15 Jan)
*** DONE Write report
CLOSED: [2012-01-29 Sun 00:35] SCHEDULED: <2012-01-13 Fri>
- State "DONE"       from ""           [2012-01-29 Sun 00:35]
*** Problems with pattern coverage
What is the difference between these two definitions?

#+BEGIN_SRC
if' True a b = a
if' _    a b = b

if'' True  a b = a
if'' False a b = b
#+END_SRC

if'' will have that everything but True and False goes to bottom,
and if' will have that everything but True and Bottom goes to b.

Is this OK?
*** DONE Equistential quantification in cnf
CLOSED: [2012-01-29 Sun 00:38]
- State "DONE"       from ""           [2012-01-29 Sun 00:38]
*** DONE Fixed point induction
CLOSED: [2012-01-16 Mon 12:35]
**** DONE Good when you don't have anything to do induction on
CLOSED: [2012-01-13 Fri 13:07]
**** DONE Examples of examples
CLOSED: [2012-01-13 Fri 13:07]
***** map-iterate
***** repeat-iterate
***** append / plus
***** mirror-treeIterate
**** DONE On mutual and subset of occuring functions
CLOSED: [2012-01-13 Fri 13:06]
**** DONE How it was implemented
CLOSED: [2012-01-13 Fri 13:06]
**** DONE Future work: depth machines
CLOSED: [2012-01-16 Mon 12:35]
*** DONE Structural induction
CLOSED: [2012-01-16 Mon 12:35]
**** Compare to normal PA induction
**** Chain complete predicates -> infinite properties
**** Structural induction on exponential types
**** Deeper structural induction
**** Future work: induction machines
*** DONE Related work
CLOSED: [2012-01-16 Mon 12:34]
**** DONE Coinduction work in Agda by NAD
CLOSED: [2012-01-16 Mon 12:35]
* Plan
#+BEGIN: clocktable :maxlevel 4 :scope subtree
Clock summary at [2012-02-05 Sun 00:37]

| Headline                                                      | Time    |       |       |      |
|---------------------------------------------------------------+---------+-------+-------+------|
| *Total time*                                                  | *41:27* |       |       |      |
|---------------------------------------------------------------+---------+-------+-------+------|
| Plan                                                          | 41:27   |       |       |      |
| Completed                                                     |         | 28:50 |       |      |
| DONE Fix the lambda bug                                       |         |       |  0:42 |      |
| DONE Fill results incrementally                               |         |       |  1:22 |      |
| DONE Patch the program to run all provers                     |         |       |  9:08 |      |
| DONE Modify the code to accept both modes                     |         |       |       | 6:43 |
| DONE SPASS                                                    |         |       |       | 0:32 |
| DONE Prover9                                                  |         |       |       | 0:29 |
| DONE Equinox                                                  |         |       |       | 0:27 |
| DONE Vampire                                                  |         |       |       | 0:11 |
| SOMEDAY Waldmeister (?)                                       |         |       |       | 0:15 |
| DONE Make a test suite that discovers how the provers answers |         |       |       | 0:16 |
| DONE Meeting with Koen 31 january                             |         |       |  1:04 |      |
| DONE Install GHC on ttitania                                  |         |       |  1:03 |      |
| DONE Results                                                  |         |       | 15:10 |      |
| NEXT Prepare the test suite                                   |         |       |       | 7:20 |
| NEXT Histogram statistics                                     |         |       |       | 2:01 |
| NEXT Table statistics                                         |         |       |       | 0:48 |
| DONE What to track?                                           |         |       |       | 1:56 |
| DONE Use qsub scriptd                                         |         |       |       | 1:04 |
| DONE Disable combinatorial explosions from fpi and str ind    |         |       |       | 1:53 |
| Report                                                        |         |       |  0:21 |      |
| DONE Quantifying functions and app                            |         |       |       | 0:21 |
| Tasks                                                         |         |  0:35 |       |      |
| ONGOING Time planning                                         |         |       |  0:34 |      |
| TODO Report tasks                                             |         | 12:02 |       |      |
| NEXT Write introduction                                       |         |       |  2:33 |      |
| TODO Translation                                              |         |       |  0:14 |      |
| DONE Revert to the old translation technique                  |         |       |       | 0:14 |
| TODO Proof methods                                            |         |       |  1:14 |      |
| TODO Fixed point induction                                    |         |       |       | 0:55 |
| TODO Future work                                              |         |       |  2:51 |      |
| DONE Pattern matching rerevisited                             |         |       |       | 0:29 |
| NEXT Lemmas and translation                                   |         |       |       | 2:22 |
| TODO Results                                                  |         |       |  3:00 |      |
#+END:
** Refile
*** SOMEDAY Example ideas
**** Feldspar examples
**** Case-Analysis from Moa's project
[[http://dream.inf.ed.ac.uk/projects/lemmadiscovery/case_results.php][Case-Analysis Results]]
These are exactly those imported from Zeno

*** SOMEDAY Test translation by generating code

*** SOMEDAY Have a lab day to enlargen the test suite
*** SOMEDAY Remove =/= and add oops
And add some oops keyword instead, and handle those separately. If it
was able to prove something of that kind, alarm!!

*** SOMEDAY Interpret equality flag
We can express how to interpret equality with something like
#+BEGIN_SRC haskell
{-# OPTIONS_EQUALITY Queue toList #-}
#+END_SRC

for

#+BEGIN_SRC haskell
instance Eq a => Eq (Queue a) where
  q == q' = toList q == toList q'
#+END_SRC

but it seems really tricky to enforce the variant that front is never
empty if back isn't. (i.e. if the back is nonempty, then the front is
too)
*** SOMEDAY Zeno mistake?
There was one (or two?) example in the Zeno testsuite that was not a
theorem. Maybe this is why they could not prove some in their
paper. Mail authors?

** Completed
*** DONE Good bibtex, bad bibtex
CLOSED: [2012-01-29 Sun 00:35]
- State "DONE"       from ""           [2012-01-29 Sun 00:35]
*** DONE Hasse diagrams
CLOSED: [2012-01-29 Sun 00:35]
- State "DONE"       from ""           [2012-01-29 Sun 00:35]
*** DONE Approximation lemma
CLOSED: [2012-01-29 Sun 00:39]
- State "DONE"       from "TODO"       [2012-01-29 Sun 00:39]
Leave out the details about
Can we really do finite approximation lemma? Is this really chain
complete? Find a counterexample or prove its correctness. The total
predicate is chain complete? Are there any sensible chains? Aaah!
*** DONE Adimissibility of equality
CLOSED: [2012-01-29 Sun 00:36]
- State "DONE"       from ""           [2012-01-29 Sun 00:36]
*** DONE Induction
CLOSED: [2012-01-29 Sun 00:38]
- State "DONE"       from ""           [2012-01-29 Sun 00:38]
Over the number of constructors.  First start with only finite
induction and then introduce partial induction.
*** DONE Related work: talk with Vincent
CLOSED: [2012-01-29 Sun 00:39]
- State "DONE"       from ""           [2012-01-29 Sun 00:39]
*** DONE Examples
**** DONE Add merge sort
CLOSED: [2011-11-02 Wed 10:22]
*** DONE Mail about presentation on FP meeting time
CLOSED: [2012-01-30 Mon 17:29]
- State "DONE"       from "NEXT"       [2012-01-30 Mon 17:29]
*** DONE Fix the lambda bug
CLOSED: [2012-02-02 Thu 09:01]
- State "DONE"       from "TODO"       [2012-02-02 Thu 09:01]
Ok, removed one line from the translation, seems to work, but should
look into this in more detail. :)
CLOCK: [2012-02-01 Wed 16:50]--[2012-02-01 Wed 17:32] =>  0:42
*** DONE Fill results incrementally
CLOSED: [2012-02-01 Wed 16:23]
- State "DONE"       from "TODO"       [2012-02-01 Wed 16:23]
CLOCK: [2012-02-01 Wed 15:01]--[2012-02-01 Wed 16:23] =>  1:22

*** DONE Patch the program to run all provers
CLOSED: [2012-02-02 Thu 09:18]
- State "DONE"       from "NEXT"       [2012-02-02 Thu 09:18]
CLOCK: [2012-01-31 Tue 11:19]--[2012-01-31 Tue 11:23] =>  0:04
CLOCK: [2012-01-30 Mon 10:48]--[2012-01-30 Mon 10:49] =>  0:01
CLOCK: [2012-01-30 Mon 10:03]--[2012-01-30 Mon 10:12] =>  0:09
CLOCK: [2012-01-29 Sun 15:11]--[2012-01-29 Sun 15:12] =>  0:01
:PROPERTIES:
:ORDERED: t
:END:
**** DONE Modify the code to accept both modes
I think I refered to GUI/text mode here, but there won't be a GUI
created as for now.
CLOSED: [2012-02-02 Thu 09:19]
- State "DONE"       from "NEXT"       [2012-02-02 Thu 09:19]
CLOCK: [2012-01-30 Mon 22:16]--[2012-01-31 Tue 00:25] =>  2:09
CLOCK: [2012-01-30 Mon 17:31]--[2012-01-30 Mon 18:24] =>  0:53
CLOCK: [2012-01-30 Mon 16:39]--[2012-01-30 Mon 17:29] =>  0:50
CLOCK: [2012-01-30 Mon 13:47]--[2012-01-30 Mon 15:30] =>  1:43
CLOCK: [2012-01-30 Mon 10:55]--[2012-01-30 Mon 11:49] =>  0:54
CLOCK: [2012-01-30 Mon 09:49]--[2012-01-30 Mon 10:03] =>  0:14
CLOCK: [2012-01-30 Mon 08:54]--[2012-01-30 Mon 08:54] =>  0:00
:PROPERTIES:
:ORDERED: t
:END:
***** DONE Remove the "finite success" ideas?
CLOSED: [2012-02-02 Thu 09:02]
- State "DONE"       from ""           [2012-02-02 Thu 09:02]
This would lead to much easier collapsing
***** How to handle proof methods that have more than one invocation?
Flag

***** DONE Give a flag to give up on a proof if a certain step failed on all provers
CLOSED: [2012-02-02 Thu 09:02]
- State "DONE"       from ""           [2012-02-02 Thu 09:02]
***** Randomize the order of doing proofs
Maybe just add some randomization?
**** DONE SPASS
CLOSED: [2012-01-30 Mon 10:48]
- State "DONE"       from "TODO"       [2012-01-30 Mon 10:48]
CLOCK: [2012-01-30 Mon 10:22]--[2012-01-30 Mon 10:23] =>  0:01
CLOCK: [2012-01-29 Sun 16:13]--[2012-01-29 Sun 16:15] =>  0:02
CLOCK: [2012-01-29 Sun 15:12]--[2012-01-29 Sun 15:32] =>  0:20
***** Time limit in seconds
***** Bash invocation
SPASS -TPTP -PGiven=0 -PProblem=0 -DocProof=0 -PStatistic=0 -TimeLimit=1
***** Answer format
****** CounterSatisfiable and Satisfiable
SPASS beiseite: Completion found.
****** Theorem and Unsatisfiable
SPASS beiseite: Proof found.
***** WAITING Answer format - mail
- State "WAITING"    from ""           [2012-01-29 Sun 15:41] \\
  Sent a mail to the SPASS team
CLOCK: [2012-01-29 Sun 15:32]--[2012-01-29 Sun 15:41] =>  0:09
SPASS beiseite: Proof found.
***** Ubuntu
Exists in ubuntu repo, but that won't help on ttitania. Needs
binaries.
***** stdin
Just give -Stdin option
***** auto
Give -Auto option
**** DONE Prover9
CLOSED: [2012-01-30 Mon 10:48]
- State "DONE"       from "TODO"       [2012-01-30 Mon 10:48]
CLOCK: [2012-01-30 Mon 10:12]--[2012-01-30 Mon 10:22] =>  0:10
CLOCK: [2012-01-29 Sun 16:15]--[2012-01-29 Sun 16:18] =>  0:03
CLOCK: [2012-01-29 Sun 15:57]--[2012-01-29 Sun 15:57] =>  0:00
CLOCK: [2012-01-29 Sun 15:41]--[2012-01-29 Sun 15:57] =>  0:16
Go with tptp_to_ladr first, can fix it later. Must run own script
tptp_to_ladr < $FILE | runghc Util/FixLADR.hs | timeout 1 prover9 > prover9/$BASE.out 2> err
***** Answer format
****** CounterSatisfiable and Satisfiable
SEARCH FAILED
****** Theorem and Unsatisfiable
THEOREM PROVED
***** Default is lots of proof output, and not with SZS
**** DONE Equinox
CLOSED: [2012-02-02 Thu 09:02]
- State "DONE"       from "TODO"       [2012-02-02 Thu 09:02]
Cannot get this to compile
The precompiled binaries seem to be for 32 bit
./equinox: error while loading shared libraries: libgmp.so.10: wrong ELF class: ELFCLASS64
CLOCK: [2012-01-30 Mon 10:23]--[2012-01-30 Mon 10:48] =>  0:25
CLOCK: [2012-01-29 Sun 16:30]--[2012-01-29 Sun 16:32] =>  0:02
**** DONE Vampire
CLOSED: [2012-01-30 Mon 10:48]
- State "DONE"       from "TODO"       [2012-01-30 Mon 10:48]
CLOCK: [2012-01-29 Sun 16:19]--[2012-01-29 Sun 16:30] =>  0:11
CLOCK: [2012-01-29 Sun 16:19]--[2012-01-29 Sun 16:19] =>  0:00
***** Answer format
Answers with the SZS ontology directly
% SZS status Unsatisfiable for unknown
But fails to produce proofs for SAT and CSA
**** SOMEDAY Waldmeister (?)
- State "TODO"       from "DONE"       [2012-01-30 Mon 10:48]
- State "DONE"       from "TODO"       [2012-01-30 Mon 10:48]
CLOCK: [2012-01-29 Sun 16:48]--[2012-01-29 Sun 16:48] =>  0:00
CLOCK: [2012-01-29 Sun 16:34]--[2012-01-29 Sun 16:48] =>  0:14
CLOCK: [2012-01-29 Sun 16:32]--[2012-01-29 Sun 16:33] =>  0:01
Writes careful proof output
**** DONE Make a test suite that discovers how the provers answers
CLOSED: [2012-01-29 Sun 16:29]
- State "DONE"       from "TODO"       [2012-01-29 Sun 16:29]
CLOCK: [2012-01-29 Sun 15:57]--[2012-01-29 Sun 16:13] =>  0:16

*
*** DONE Meeting with Koen 31 january
CLOSED: [2012-01-31 Tue 13:58] SCHEDULED: <2012-01-30 Mon 13:00>
CLOCK: [2012-01-31 Tue 17:41]--[2012-01-31 Tue 17:46] =>  0:05
- State "DONE"       from "MEETING"    [2012-01-31 Tue 13:58]
CLOCK: [2012-01-31 Tue 12:59]--[2012-01-31 Tue 13:58] =>  0:59
**** Teaser on Tuesday
Just present the problem and demo what we can do. Briefly describe
some of the technical details, but more will come on the real presentation

**** Submit some problems to System on TPTP
Of different kinds, some easy, some hard, some that only a few theorem
provers are good on, some non-theorems, and so on, to the software
verification section. This could be fun!

**** Got equinox to compile and can now read from standand input

**** Mail report tonight
SCHEDULED: <2012-01-31 Tue>

**** Cactus diagrams, scatter plots
Put different provers and proving methods against each other.
Provers in cactus diagram, fixpoint induction vs approx lemma in
scatter plots?

*** DONE Install GHC on ttitania
CLOSED: [2012-02-02 Thu 10:28]
- State "DONE"       from "NEXT"       [2012-02-02 Thu 10:28]
CLOCK: [2012-02-02 Thu 09:25]--[2012-02-02 Thu 10:28] =>  1:03
ttitania is 64 bit
ttitania-1.ce.chalmers.se
All provers installed!
*** DONE Results
CLOSED: [2012-02-04 Sat 14:38]
- State "DONE"       from "TODO"       [2012-02-04 Sat 14:38]
CLOCK: [2012-02-02 Thu 09:23]--[2012-02-02 Thu 09:25] =>  0:02
CLOCK: [2012-02-01 Wed 23:45]--[2012-02-01 Wed 23:48] =>  0:03
CLOCK: [2012-01-31 Tue 11:33]--[2012-01-31 Tue 11:36] =>  0:03
CLOCK: [2012-01-30 Mon 10:48]--[2012-01-30 Mon 10:48] =>  0:00

**** NEXT Prepare the test suite
CLOCK: [2012-02-02 Thu 23:19]--[2012-02-03 Fri 00:40] =>  1:21
CLOCK: [2012-02-02 Thu 21:30]--[2012-02-02 Thu 21:57] =>  0:27
CLOCK: [2012-02-02 Thu 18:29]--[2012-02-02 Thu 18:29] =>  0:00
CLOCK: [2012-02-02 Thu 17:00]--[2012-02-02 Thu 18:00] =>  1:00
CLOCK: [2012-02-02 Thu 13:11]--[2012-02-02 Thu 14:07] =>  0:56
CLOCK: [2012-02-02 Thu 12:32]--[2012-02-02 Thu 12:50] =>  0:18
CLOCK: [2012-02-01 Wed 23:00]--[2012-02-01 Wed 23:39] =>  0:39
CLOCK: [2012-02-01 Wed 13:10]--[2012-02-01 Wed 14:46] =>  1:36
CLOCK: [2012-02-01 Wed 12:37]--[2012-02-01 Wed 12:39] =>  0:02
CLOCK: [2012-02-01 Wed 11:36]--[2012-02-01 Wed 12:37] =>  1:01
Rename and describe everything. Remove duplicate properties (for
example, list concatenation associativity is in a myriad of files).
***** DONE Fixes
CLOSED: [2012-02-03 Fri 11:37]
- State "DONE"       from "TODO"       [2012-02-03 Fri 11:37]
****** DONE merge Expr and BoolExpr
CLOSED: [2012-02-02 Thu 13:31]
- State "DONE"       from ""           [2012-02-02 Thu 13:31]
****** DONE rename NobodyExpectsTheScottInduction
CLOSED: [2012-02-03 Fri 11:37]
- State "DONE"       from ""           [2012-02-03 Fri 11:37]
****** DONE maybe try some other sorting (selection sort, merge sort)
CLOSED: [2012-02-03 Fri 11:37]
- State "DONE"       from ""           [2012-02-03 Fri 11:37]
****** DONE Cannot do structural induction on Expressions. Need to fix this
CLOSED: [2012-02-03 Fri 11:37]
- State "DONE"       from "TODO"       [2012-02-03 Fri 11:37]

***** Overlap
Reverse and insertion sort are (probably) defined in productive use of
failure already
**** NEXT Histogram statistics
CLOCK: [2012-02-03 Fri 13:10]--[2012-02-03 Fri 13:11] =>  0:01
CLOCK: [2012-02-03 Fri 11:42]--[2012-02-03 Fri 13:10] =>  1:28
CLOCK: [2012-02-03 Fri 11:07]--[2012-02-03 Fri 11:39] =>  0:32
Exteremly hard to get something readable or interesting from this
log log plots look okay, but the problem is that they cannot handle 0,
and futhermore wide blocks don't add much

The best so far is just to have cumulative and it just shows that
after 300ms or so, almost no theorems where proved, and that arond
around 1000 were proved in less than 10ms.

**** NEXT Table statistics
CLOCK: [2012-02-03 Fri 10:19]--[2012-02-03 Fri 11:07] =>  0:48
Make a latex table of statistics from the different files

**** SOMEDAY Enable plotting two proving methods (fpi/approx) against each other
As a scatter plot. Need the (sum) success time for them. If several
fpi worked, take the best. This could be an interesting plot.

**** DONE What to track?
CLOSED: [2012-02-02 Thu 20:29]
- State "DONE"       from "NEXT"       [2012-02-02 Thu 20:29]
CLOCK: [2012-02-02 Thu 18:33]--[2012-02-02 Thu 20:29] =>  1:56
***** Number of solved properties for each solver
***** Number of solved properties for each proof method
****** Strutural induction: Try different depths, and the number of variables
***** Store all success times and try plot
****** Cactus plot
****** Histogram
****** Scatter plot comparisons?

**** DONE Use qsub scriptd
CLOSED: [2012-02-02 Thu 21:58]
- State "DONE"       from "NEXT"       [2012-02-02 Thu 21:58]
CLOCK: [2012-02-02 Thu 20:29]--[2012-02-02 Thu 21:10] =>  0:41
CLOCK: [2012-02-02 Thu 10:28]--[2012-02-02 Thu 10:51] =>  0:23
#+BEGIN_SRC bash
L=/home/palka/.local_inst
export LIBRARY_PATH=$LIBRARY_PATH:$L/lib:$L/usr/lib
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$L/lib:$L/usr/lib

#if [[ -z $1 || $1 == "--help" ]]
#then
#  echo "usage: $0 <testing binary> <number of terms> <number of tests>"
#fi

OLDWD=$PWD

DIR=run_${JOB_ID}_$SGE_TASK_ID

rm -rf $DIR
mkdir $DIR

cd $DIR

time $OLDWD/$1 $2 $3 $4

--

qsub -cwd -q fp -t 1-100 ../runTest.sh ./testStrictness 1000
10 /home/palka/packages/ghc-7.3.20111022-inst/bin/ghc
#+END_SRC

-cwd    : current working directory
-q fp   : use the FP queue
-t n-m  : set $SGE_TASK_ID . this will be useful to do different kinds
          of tests

**** DONE Disable combinatorial explosions from fpi and str ind
CLOCK: [2012-02-02 Thu 14:17]--[2012-02-02 Thu 16:10] =>  1:53
CLOSED: [2012-02-02 Thu 17:32]
- State "DONE"       from "NEXT"       [2012-02-02 Thu 17:32]

*** Report                                                         :report:
**** DONE Quantifying functions and app
CLOSED: [2012-01-31 Tue 11:54]
- State "DONE"       from "NEXT"       [2012-01-31 Tue 11:54]
CLOCK: [2012-01-31 Tue 11:36]--[2012-01-31 Tue 11:47] =>  0:11
CLOCK: [2012-01-31 Tue 11:23]--[2012-01-31 Tue 11:33] =>  0:10
** Tasks
CLOCK: [2012-01-29 Sun 14:52]--[2012-01-29 Sun 14:53] =>  0:01
*** ONGOING Time planning
CLOCK: [2012-02-04 Sat 14:40]--[2012-02-04 Sat 14:51] =>  0:11
CLOCK: [2012-02-02 Thu 09:14]--[2012-02-02 Thu 09:14] =>  0:00
CLOCK: [2012-02-02 Thu 09:01]--[2012-02-02 Thu 09:05] =>  0:04
CLOCK: [2012-02-01 Wed 09:59]--[2012-02-01 Wed 10:00] =>  0:01
CLOCK: [2012-02-01 Wed 09:59]--[2012-02-01 Wed 09:59] =>  0:00
CLOCK: [2012-02-01 Wed 09:58]--[2012-02-01 Wed 09:58] =>  0:00
CLOCK: [2012-02-01 Wed 09:57]--[2012-02-01 Wed 09:57] =>  0:00
CLOCK: [2012-01-31 Tue 12:01]--[2012-01-31 Tue 12:02] =>  0:01
CLOCK: [2012-01-31 Tue 10:12]--[2012-01-31 Tue 10:12] =>  0:00
CLOCK: [2012-01-30 Mon 17:29]--[2012-01-30 Mon 17:31] =>  0:02
CLOCK: [2012-01-30 Mon 08:48]--[2012-01-30 Mon 08:50] =>  0:02
CLOCK: [2012-01-29 Sun 15:06]--[2012-01-29 Sun 15:07] =>  0:01
CLOCK: [2012-01-29 Sun 15:00]--[2012-01-29 Sun 15:06] =>  0:06
CLOCK: [2012-01-29 Sun 14:57]--[2012-01-29 Sun 15:00] =>  0:03
CLOCK: [2012-01-29 Sun 14:53]--[2012-01-29 Sun 14:56] =>  0:03
:PROPERTIES:
:ORDERED: t
:END:

*** TODO Better name than autospec!

*** TODO Presentation
**** CANCELLED GTK2Hs frontend for proofs for presentation
CLOSED: [2012-02-04 Sat 14:39]1
**** TODO Ideas on live examples
**** NEXT

*** TODO Mail Abstract to Meng
DEADLINE: <2012-02-03 Fri>
*** TODO Final presentation
SCHEDULED: <2012-02-10 Fri>
*** TODO Report complete
DEADLINE: <2012-02-14 Tue>
** TODO Report tasks                                                :report:
CLOCK: [2012-02-04 Sat 14:51]--[2012-02-04 Sat 15:05] =>  0:14
CLOCK: [2012-02-03 Fri 16:44]--[2012-02-03 Fri 18:39] =>  1:55
CLOCK: [2012-01-31 Tue 14:26]--[2012-01-31 Tue 14:27] =>  0:01
*** NEXT Write introduction
CLOCK: [2012-02-01 Wed 10:31]--[2012-02-01 Wed 10:58] =>  0:27
CLOCK: [2012-02-01 Wed 10:00]--[2012-02-01 Wed 10:26] =>  0:26
Shit this is hard
CLOCK: [2012-01-31 Tue 18:08]--[2012-01-31 Tue 19:22] =>  1:14
CLOCK: [2012-01-31 Tue 17:46]--[2012-01-31 Tue 18:02] =>  0:16
CLOCK: [2012-01-31 Tue 17:39]--[2012-01-31 Tue 17:41] =>  0:02
CLOCK: [2012-01-31 Tue 14:35]--[2012-01-31 Tue 14:43] =>  0:08
CLOCK: [2012-01-31 Tue 14:28]--[2012-01-31 Tue 14:28] =>  0:00
Write this: introduce the problem and why it is interesting
Get to the point! Don't be hand-wavy
*** TODO Abstract
*** TODO Introduction
*** TODO Related work
**** TODO Talk with Moa on winter meeting
*** TODO Translation
CLOCK: [2012-02-04 Sat 22:15]--[2012-02-04 Sat 22:15] =>  0:00
**** TODO Where to put the domain theory part?
**** DONE Revert to the old translation technique
CLOSED: [2012-02-04 Sat 22:29]
- State "DONE"       from "NEXT"       [2012-02-04 Sat 22:29]
CLOCK: [2012-02-04 Sat 22:15]--[2012-02-04 Sat 22:29] =>  0:14
This needs to introduce the fancy techinque later on
*** TODO Proof methods
CLOCK: [2012-01-31 Tue 11:47]--[2012-01-31 Tue 11:54] =>  0:07
CLOCK: [2012-01-31 Tue 10:12]--[2012-01-31 Tue 10:24] =>  0:12
**** TODO Fixed point induction
- State "TODO"       from "DONE"       [2012-01-31 Tue 18:50]
- State "DONE"       from "NEXT"       [2012-01-31 Tue 18:50]
CLOCK: [2012-01-31 Tue 10:24]--[2012-01-31 Tue 11:19] =>  0:55
Overhaul and introduce the fancy notation earlier?
Redo the section called Implementation. How can we minimize the
explanation of fix? Probably, a lot of proofs can be removed too, that
are not too interesting and just state them as properties easily
proved by induction (or something)

**** NEXT Concrete concerns
*** TODO Abstract
*** TODO Introduction
**** TODO Schematic view of this work
Haskell -> Logic -> ATP invocations -> Results
*** TODO Related work
CLOCK: [2012-02-05 Sun 01:15]--[2012-02-05 Sun 01:29] =>  0:14
**** TODO Talk to Moa on the winter meeting
*** TODO Translation
**** Where to put the domain theory part?
*** TODO Proof methods
*** TODO Future work
**** TODO Implications
Chain complete?
#+BEGIN_SRC haskell
x + y = x + z -> y = x
#+END_SRC
needs induction on the whole property, you cannot simply the
antecedent as a lemma
**** CANCELLED How does the min predicate work
CLOSED: [2012-01-29 Sun 00:36]
- State "CANCELLED"  from ""           [2012-01-29 Sun 00:36] \\
***** TODO Min predicate:
Just write in the report that it is possible
**** DONE Pattern matching rerevisited
CLOSED: [2012-02-04 Sat 23:26]
- State "DONE"       from "NEXT"       [2012-02-04 Sat 23:26]
CLOCK: [2012-02-04 Sat 22:57]--[2012-02-04 Sat 23:26] =>  0:29
**** NEXT Lemmas and translation
CLOCK: [2012-02-05 Sun 00:43]--[2012-02-05 Sun 01:13] =>  0:30
CLOCK: [2012-02-04 Sat 23:26]--[2012-02-05 Sun 00:37] =>  1:11
CLOCK: [2012-02-04 Sat 22:29]--[2012-02-04 Sat 22:57] =>  0:28
CLOCK: [2012-02-04 Sat 21:54]--[2012-02-04 Sat 22:15] =>  0:21
CLOCK: [2012-02-04 Sat 16:57]--[2012-02-04 Sat 17:10] =>  0:13
CLOCK: [2012-02-04 Sat 15:05]--[2012-02-04 Sat 15:14] =>  0:09
:PROPERTIES:
:ORDERED: t
:END:
Here we can elaborate on different ways of translating, how to use
predicates and if we should pattern match on all constructors and make
the wild pattern always go to []. Say something about how this can be
problematic with GADTs and other fancy type extensions.
***** Schematic view of lemmas with/without QuickSpec
**** Refutation
Refutation is a proof that ends in $false
[[http://www.cs.miami.edu/~tptp/TPTP/TPTPTParty/2007/PositionStatements/GeoffSutcliffe_SZS.html][SZS Output Ontology]]
*** TODO Results
CLOCK: [2012-02-03 Fri 15:55]--[2012-02-03 Fri 16:44] =>  0:49
CLOCK: [2012-02-03 Fri 13:47]--[2012-02-03 Fri 15:55] =>  2:08
CLOCK: [2012-02-03 Fri 11:39]--[2012-02-03 Fri 11:42] =>  0:03
**** TODO Refer to the different theorem provers
Prover9 has a bibtex
**** TODO SZS Status ontology paper
*** TODO Conclusions
This may need some thinking :)
*** Misc
**** TODO How does Zeno handle typeclasses?
**** TODO Put "propositional equality" somewhere, not Eq-equaliy
**** TODO Quantify over functions: restrict them to be monotone?
Is this really important?
Maybe blend this with type classes? Abstract implementations of
functions from typeclasses are at least monotone, and could respect
the typeclass equalities.

