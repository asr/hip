\chapter{Haskell to First Order Logic}

To enable automated theorem provers to do equational reasoning of
Haskell programs, we translate them to first order logic. It is
referred to as a translation, but it could also be regarded as a
compilation. The idea is to use constants and functions in first order
logic to correspond to constructors and functions, and arguments to
functions need to be universally quantified. We shall try to do a
na\"{\i}ve attempt of a translation with this ideas and see how far it
takes us.

\section{Na\"{\i}ve translation}

We will use a data type of binary trees with an element at every
branch, and consider some examples of functions defined on it. This
is the Haskell definition of the data type we will be using:

\begin{code}
data Tree a = Fork (Tree a) a (Tree a) | Leaf
\end{code}
With the idea above, occurrences of the \hs{Fork} constructor in the
source code should be translated to a logic function $\fn{fork}$, and
similarly a constant for \hs{Leaf}. How should we then translate the
\hs{singleton} function, defined below?

\begin{code}
singleton :: a -> Tree a
singleton x = Fork Leaf x Leaf
\end{code}

\noindent
Following our intuition and make an universal quantification for
\hs{x}, and make a new logic function for \hs{singleton}. The result
is this axiom:
\begin{equation*}
\fa{x} \fn{singleton}(x) = \fn{fork}(\fn{leaf},x,\fn{leaf})
\end{equation*}

\noindent
So far so good, but what if someone wants to prove that \hs{singleton x}
is a \hs{Leaf}? With only this axiom in the theory, it would be
possible: there are models with only one element where \hs{Leaf} is
equal to \hs{Fork}. Indeed, we will need to add axioms that values
created from the different constructors are unequal. We will call
those disjoint constructor axioms, and for the \hs{Tree} data type, we
get this axiom:
\begin{equation*}
\faaa{l}{x}{r} \fn{leaf} \neq \fn{fork}(l,x,r)
\end{equation*}

Constructors should also be injective to get regular models, and
adding such axioms are straightforward. Since \hs{Fork} has arguments,
it needs an injectivity axiom:
\begin{equation*}
\faaaaaa{l_0}{l_1}{x_0}{x_1}{r_0}{r_1} \fn{fork}(l_0,x_0,r_0) \eq
\fn{fork}(l_1,x_1,r_1) \rightarrow l_0 \eq l_1 \wedge x_0 \eq x_1 \wedge r_0 \eq r_1
\end{equation*}

For the \hs{mirror} function, which recursively mirrors the left sub
tree with the right and vice-versa, we follow our intuition to
translate the pattern matching and get these two axioms\footnote
{Axioms are enumerated by Roman numerals to tell them apart.}:

\begin{code}
mirror :: Tree a -> Tree a
mirror (Fork l x r) = Fork (mirror r) x (mirror l)
mirror Leaf         = Leaf
\end{code}
\begin{align*}
\rom{1} && \faaa{l}{x}{r} & \fn{mirror}(\fn{fork}(l,x,r)) \eq \fn{fork}(\fn{mirror}(r),x,\fn{mirror}(l)) \\
\rom{2} &&                & \fn{mirror}(\fn{leaf}) \eq \fn{leaf}
\end{align*}

\noindent
A problem with this translation is that there are no axioms for other
arguments of $\fn{mirror}$ than leafs and forks, and we have models that
include other values than leafs and forks. Another problem is
encountered for \hs{singleton}'s left inverse, \hs{top}, code below,
which returns the top element of a \hs{Tree}. This is a partial
function since it does not cover all patterns.

\begin{code}[label=lst:top]
top :: Tree a -> a
top (Fork l x r) = x
\end{code}

The translation must capture the pattern match failure that results
from trying to evaluate top applied to a leaf. We conclude that
this na\"{\i}ve translation does not take us further, but we shall see
in the next section how to fix this.

\section{Bottom and pattern matching}

In domain theory there is a concept of bottom, denoted $\bot$. It is
used for the least defined value: pattern match failures, use of
\hs{error} and \hs{undefined} in the source code, but also for
non-terminating programs.  \note{Refer to a short introduction of
  domain theory at the end of this chapter (or elsewhere, appendix?)}
For \hs{top} the idea is to add an axiom so that \fn{top} of anything
that is not a \hs{Fork} is bottom. This is an example of such an
axiomatization:
\begin{align*}
\rom{1} \qquad & \faaa{l}{x}{r} \fn{top}(\fn{fork}(l,x,r)) \eq \fn{fork}(\fn{mirror}(r),x,\fn{mirror}(l)) \\
\rom{2} \qquad & \fa{t}         (\nexxx{l}{x}{r} \fn{fork}(l,x,r)) \eq t) \rightarrow \fn{top}(t) \eq \bot
\end{align*}

Most theorem provers would \note{citation needed}skolemize the second
axiom. A new unary function would be introduced for $l$, $x$ and $r$,
depending on $i$, an arbitrary choice of names are $\fn{top}$
appended to the original variable. The axiom becomes:
\begin{align*}
\rom{2}' \qquad & \fa{t} (\fn{fork}(\fn{topl}(t),\fn{topx}(t),\fn{topr}(t))) \neq t) \rightarrow \fn{top}(t) \eq \bot
\end{align*}

For another function, like \hs{mirror} above, the skolemized function
could be called $\fn{mirror}$ and the variable name. Since axioms of
injective constructors are also added, we could conclude that
$\faaa{l}{x}{r} \fn{mirrorl}(\fn{fork}(l,x,r)) \eq
\fn{topl}(\fn{fork}(l,x,r)) \eq l$. But what happens if we introduce
such skolemized ``selector'' functions for every constructor manually?
We call them $\fn{fork_0}$ up to $\fn{fork_2}$, and their axioms are:
\begin{align*}
\rom{1} \qquad \faaa{l}{x}{r} \fn{fork_{0}}(\fn{fork}(l,x,r)) & \eq l\\
\rom{2} \qquad \faaa{l}{x}{r} \fn{fork_{1}}(\fn{fork}(l,x,r)) & \eq x\\
\rom{3} \qquad \faaa{l}{x}{r} \fn{fork_{2}}(\fn{fork}(l,x,r)) & \eq r
\end{align*}

\noindent
The translation of \hs{top} with these selector functions is:
\begin{align*}
\rom{1} \qquad & \faaa{l}{x}{r} \fn{top}(\fn{fork}(l,x,r)) \eq \fn{fork}(\fn{mirror}(r),x,\fn{mirror}(l)) \\
\rom{2} \qquad & \fa{t}         (\fn{fork}(\fn{fork_0}(t),\fn{fork_1}(t),\fn{fork_2}(t))) \neq t) \rightarrow \fn{top}(t) \eq \bot
\end{align*}

\noindent
Another nice side effect of writing in this skolemized selector style
is that implies injective constructors. Assume we have
$\fn{fork}(l_0,x_0,r_0)=\fn{fork}(l_1,x_1,r_1)$ then the first
projection, $\fn{fork_0}$, gives us that $l_0=l_1$. Analogously, and
the second and the third give $x_0=x_1$ and $r_0=r_1$,
respectively. Thus selector axioms are added in place of of
injectivity axioms.

With the bottom constant in the theory, the axioms disjointedness of
needs to be added. It can be seen as an implicit constructor for every
data type. For the \hs{Tree} data type the axioms are:

\begin{align*}
\rom{1} \qquad & \faaa{l}{x}{r} \fn{fork}(l,x,r) \neq \fn{leaf} \\
\rom{2} \qquad & \faaa{l}{x}{r} \fn{fork}(l,x,r) \neq \bot      \\
\rom{3} \qquad & \bot \neq \fn{leaf}
\end{align*}

Now we have a good idea how to translate pattern matching, but
in Haskell we can pattern match almost everywhere! How would we
proceed to translate a function like this, taken from the
implementation of \hs{scanr} in the \hs{Prelude}?

\begin{code}
scanr             :: (a -> b -> b) -> b -> [a] -> [b]
scanr f q0 []     =  [q0]
scanr f q0 (x:xs) =  f x q : qs
                     where qs = scanr f q0 xs
                           q = case qs of
                                 q : _ -> q
\end{code}

\noindent
There is both pattern matching on the direct arguments, but also
pattern matching in a case statements in the where function
\hs{q}. There can also be pattern matching in lambdas. To help with
these difficulties, we define an intermediate language in the next
section.

\section{The Intermediate Language}

To address the difficulties of pattern matching elsewhere than the
arguments of a function, a little small intermediate language is
designed that can only do pattern matching at a very controlled
location: in a case statement that is the entire body of a function,
and all arms are just simple expressions consisting of function and
constructor applications and variables. Haskell is translated to this,
and pattern matching at other locations is translated to this in a new
top level definition. Functions definined in \hs{let} and \hs{where}
are raised to the top level, with the necessary variables in scope as
additional arguments. The same is done for sections and lambda
functions. The BNF for the language is this:

\begin{equation*}
\begin{aligned}
\text{Variables} \quad & x,f \\
\text{Constructors} \quad & C \\
\text{Type variables} \quad & \tau \\
\text{Type constructors} \quad & T \\
\defBNF{Declarations}{decl}{ f \; \overline{x} \; \hs{=} \; body}{function declaration} \\
    \defaltBNF{f \; \hs{::} \; t}{type signature} \\
    \defaltBNF{\hs{data} \; T \; \overline{\tau} \; \hs{=} \; \overline{C \; \overline{t}}}{data type declaration} \\
\defBNF{Function body}{body}{\hs{case} \; e \; \hs{of} \; \overline{alt}}{case body} \\
    \defaltBNF{e}{expression body} \\
\defBNF{Expressions}{e}{x}{variable} \\
    \defaltBNF{f \; \overline{e}}{function application} \\
    \defaltBNF{C \; \overline{e}}{constructor application} \\
\defBNF{Alternative}{alt}{pat \rightarrow e}{branch without guard} \\
    \defaltBNF{pat \; \hs{|} \; e \rightarrow e}{branch with guard} \\
\defBNF{Pattern}{p}{x}{pattern variable} \\
    \defaltBNF{C \; \overline{p}}{constructor pattern} \\
\defBNF{Types}{t}{\tau}{type variable} \\
    \defaltBNF{t \; \rightarrow \; t}{function type} \\
    \defaltBNF{T \; \overline{\tau}}{type constructor application} \\
\defBNF{Programs}{prog}{\overline{decl}}{} \\
\end{aligned}
\end{equation*}

This language is a strict subset of Haskell. Data declarations are
added for disjointedness and selector axioms, and type signatures are
just skipped in the translation, but the proof techniques introduced
later use this information.

A function is just a function name with a number of variables, and
then a function body, which is either an expression of variables,
functions and constructors, or a case statements with an expression
scrutinee. Branches consists of a pattern, possibly with nested uses
of constructors, and an optional guard, and in the arm is an
expression.

Now we need to distinguish between two translations: the intermediate
translation from Haskell to the intermediate language, and the logic
translation from this language to first order logic.

\section{The intermediate translation}

After this section, we will only concentrate on the logic translation.

\paragraph{Argument pattern matching} A function that does pattern matching will be translated to one that
takes in unmatched arguments and with a case in the body. The
\hs{mirror} function above is thus translated to this:

\begin{code}
mirror :: Tree a -> Tree a
mirror t = case t of
   Fork l x r -> Fork (mirror r) x (mirror l)
   Leaf       -> Leaf
\end{code}

\noindent
If you do pattern matching on several arguments, the scrutinee in the
case will be a tuple of all the arguments.

\paragraph{Local definitions} Where-clauses and let-expressions are raised
to the top level, with all necessary variables as arguments. This
example of an accumulator definition of multiplication needs such a
rewrite:

\begin{code}
(*) :: Nat -> Nat -> Nat
x * y = go Zero x
  where
    go acc Zero    = acc
    go acc (Suc n) = go (acc + y) n
\end{code}

\noindent
The \hs{go} function has the \hs{y} in scope but not as argument so it
is appended to the arguments to the top level lifted version of \hs{go}:

\begin{code}
go acc Zero    y = acc
go acc (Suc n) y = go (acc + y) n y

x * y = go Zero x y
\end{code}

\noindent
Finally \hs{go} is translated using a case expression:

\begin{code}
go acc x y = case x of
     Zero  -> acc
     Suc n -> go (acc + y) n y
\end{code}

A similar translation is done for let expressions.

\paragraph{Lambda functions} These are translated to top level
definitions. Take this example of defining \hs{fmap} in terms of the
functions from the \hs{Monad} type class:

\begin{code}
fmap' :: Monad m => (a -> b) -> m a -> m b
fmap' f m = m >>= \x -> return (f x)
\end{code}

\noindent
In the lambda, \hs{f} is a free variable so it becomes an argument to
the new top level function called \hs{lambda} below:

\begin{code}
lambda f x = return (f x)

fmap' :: Monad m => (a -> b) -> m a -> m b
fmap' f m = m >>= lambda f
\end{code}

A similar translation is done for sections.

\section{Pattern matching revisited}

\paragraph{Overlapping patterns} First of all, overlapping patterns need to be removed, otherwise we
easily get an inconsistent theory, consider

\begin{code}
overlap :: Bool -> Bool
overlap b = case b of
              True -> True
              True -> False
\end{code}

Certainly, this cannot be translated to:
\begin{align*}
\rom{1} \qquad & \fn{overlap}(\fn{true}) = \fn{true} \\
\rom{2} \qquad & \fn{overlap}(\fn{true}) = \fn{false} \\
\rom{3} \qquad & \fa{b} b \neq \fn{true} \rightarrow \fn{overlap}(b) = \bot
\end{align*}

Transitivity of equality then yields $\fn{true} = \fn{false}$,
and this together with the axioms of disjoint constructors gives a
contradiction.

In Haskell, pattern matching is done from top to bottom of the
definition, making the second match of True to never occur. Thus, the
translation to FOL also removes all subsequent patterns that are
instances of any pattern above.

\paragraph{Nested patterns and bottoms} The translation also handles patterns in more than one depth. At every
location in a pattern where a constructor is matched against, a
pattern with bottom at that spot is also added, defined to
bottom. This definition that balances a tree to the left is defined
with pattern matching on depth two:

\begin{verbatim}
unbalance :: Tree a -> Tree a
unbalance (Branch (Branch l x r) y r') = unbalance (Branch l x (Branch r y r'))
unbalance (Branch l x r)               = Branch l x (unbalance r)
unbalance Empty                        = Empty
\end{verbatim}

If we could see the bottoms in Haskell, the definition would look like this:

\begin{verbatim}
unbalance :: Tree a -> Tree a
unbalance (Branch (Branch l x r) y r') = unbalance (Branch l x (Branch r y r'))
unbalance (Branch Bottom _ _)          = Bottom
unbalance (Branch l x r)               = Branch l x (unbalance r)
unbalance Empty                        = Empty
unbalance Bottom                       = Bottom
\end{verbatim}

And such an addition of bottoms is made by the translation.
\note{This writing actually discovered a bug. Report the solution and how it was tested}

\paragraph{Guards} Guards are not much of a complication. Either the guard expression is
\hs{True}, then that branch is picked. If the expression returns
bottom, then for this argument, the function is bottom. Care needs to
be taken when looking ``upwards'' the branches, to not collide with
the guards.
\note{Add example}

\section{Functions as arguments}

In Haskell, functions readily take other functions as arguments, and
functions can also be partially applied. To get the same behavior in
logic, each function gets a \emph{function pointer}, and a new binary
function is added to the language, written infix with $\fn{@}$.
\note{Should $\fn{@}$ be written infix? $\fn{app}$ prefix is also a viable option}
For instance, the if there is a binary function plus then a constant
called plus-ptr is added to the theory and this axiom:

\begin{equation*}
\forall \, x \, y \, . \, \app{(\app{\fn{plus.ptr}}{x})}{y} = \fn{plus}(x,y)
\end{equation*}

When a function is only partially applied, or a function argument is
applied, $\, @ \, $ is used. Consider the Prelude function \hs{iterate}

\begin{verbatim}
iterate :: (a -> a) -> a -> [a]
iterate f x = x : iterate f (f x)
\end{verbatim}

It is translated with $\, @ \, $ in the following way, with \hs{:} written infix:

\begin{equation*}
\forall \, f \, x \, . \, \fn{iterate}(f,x) = x : \fn{iterate}(f,\app{f}{x})
\end{equation*}

Should a function not get all its arguments, appropriate use of $\, @ \, $ is
added, as in this function which increments all elements of the list
by one using \hs{map}:

\begin{verbatim}
incr = map (plus one)
\end{verbatim}

As \hs{incr} is also written point-free or eta-reduced, \hs{map} is
only partially applied. This is the translated axiom:

\begin{equation*}
\fn{incr} = \app{\fn{map.ptr}}{(\app{\fn{plus.ptr}}{\fn{one}})}
\end{equation*}

If \hs{incr} is applied to an argument $xs$, then \hs{incr} is applied
to more arguments than it takes, so we add $\appfn$ so the
corresponding formula becomes $\app{\fn{incr}}{xs}$, and by equational
substitution from the definition of $\fn{incr}$ we get
$\app{(\app{\fn{map.ptr}}{(\app{\fn{plus.ptr}}{\fn{one}})})}{xs}$ and
the axiom of $\fn{map.ptr}$ then equals this to
$\fn{map}(\app{\fn{plus.ptr}}{\fn{one}},xs)$.

\section{Summary}

We summarize the translation in Table~\ref{tab:transtable}.

\begin{table}[h]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    Haskell                    & First Order Logic \\
    \hline
    function                   & function or constant \\
    constructor                & function or constant \\
    data type                  & disjoint constructors and selector axioms \\
    pattern matching           & removal of overlap, insertion of bottoms and upwards axioms \\
    guards                     & equality to true and bottom plus upwards axioms \\
    partial application        & $\appfn$ on pointer constant \\
    partially applied function & pointer constant and $\appfn$ rule \\
    sections, lambdas, let     & new functions with variables in scope as arguments \\
    \hline
  \end{tabular}
  \caption{Translation of different Haskell constructs
    \label{tab:transtable}
  }
\end{table}

Equational reasoning is traditional in proving corrected of Haskell
programs, but it assumes that a simple denotational semantics exists,
and there is not even a formal semantics for the language
\cite{chasingbot}.

\section{Haskell coverage}

Haskell is a big language, and translating it all in one go is a
daunting task. Therefore, some restrictions were settled to be able to
focus on proving rather than translating.  \note{Maybe move this to
  background?}  The goal was to add enough of the Haskell language to
enable to prove interesting properties, but much of the widely
available sugar in Haskell was omitted since it does not add extra
expressibility. Therefore there is no support for list comprehensions,
do-notation, pattern bindings and type classes .

A more serious omitted feature is the lack of built-in types like \hs{Int},
\hs{Integer}, \hs{Double}, \hs{Char}, etc.

Higher-kinded type variables are currently not supported.

\section{Uncategorized}

\begin{itemize}

\item Remove unnecessary definitions for a given proof

\end{itemize}

\section{Domain Theory}

This section explains some key concepts in domain theory: monotonicity
and continutity. It shows some nice partial orderings for some
domains. It also gives an example how monotonicity can be used to
check the translation for bugs, and explains why it is problematic to
do for contiunity.
