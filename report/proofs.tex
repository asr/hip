\chapter{Proof Techniques}
\label{ch:proofs}

To the tool developed in this thesis properties are entered in the
Haskell source code. A small prelude called \hs{AutoPrelude} needs to
be imported that gives access to the relevant functions. One example
is the associativity of list concatenation:

\begin{code}
import AutoPrelude

prop_app_assoc :: [a] -> [a] -> [a] -> Prop [a]
prop_app_assoc xs ys zs = xs ++ (ys ++ zs) =:= (xs ++ ys) ++ zs
\end{code}

The infix function \hs{=:=} comes from the import, as well as the type
constructor \hs{Prop}. The type signature cannot be omitted as this is
used for some proof techinques. For induction, you need to see which
kind of induction we will use.

Running the program is simple. Just save the file as for instance
\hs{ListProps.hs} and run

\begin{code}
autospec ListProps.hs
\end{code}

\noindent
and the program will report if it was provable or not, and which
techniques succeeded. Equational properties written like this are also
testable with QuickCheck, so you can run the normal \hs{quickCheck}
function on them, given that there are appropriate \hs{Eq} and
\hs{Arbitrary} instances provided.

The rest of this chapter explains the different proof methods
supported in this tool: definitional equality (Section
\ref{sec:equality}), structural induction (Section
\ref{sec:induction}), fixed point induction (Section
\ref{sec:fixpoint}) and approximation lemma (Section
\ref{sec:approx}).
% Definitional Equality -------------------------------------------------------

\input{equality}

% Structual Induction ---------------------------------------------------------

\input{induction}

% Fixpoint Induction ----------------------------------------------------------

\input{fixpoint}

% Approximation Lemma ---------------------------------------------------------

\input{approx}