\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage[margin=1.5in]{geometry}
\usepackage{parsetree}
\usepackage{verbatim}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{tipa}
\usepackage{textcomp}
\usepackage{float}
%\usepackage{courier}

\newcommand\note[1]{\mbox{}\marginpar{\footnotesize\raggedright\hspace{0pt}\emph{#1}}}
\newcommand\hs[1]{\verb~#1~}
\newcommand\fn[1]{\mathrm{#1}}
\newcommand\ptr[1]{\fn{#1.ptr}}
\newcommand\app[2]{#1 \, @ \, #2}
\newcommand\fa[1]{\forall \, #1 \, . \,}
\newcommand\faa[2]{\forall \, #1 \, #2 \, . \,}
\newcommand\faaa[3]{\forall \, #1 \, #2 \, #3 \, . \,}

\newcommand\tofix[1]{#1_{\mathrm{tofix}}}
\newcommand\unfix[1]{#1_{\mathrm{unfix}}}
\newcommand\comment[1]{}

\newcommand{\xsys}[2]{#1 \, xs \, #2 & = #1 \, ys #2}
\newcommand{\desca}[1]{  & \hspace{44.5mm}                            \{ \mathrm{#1} \}}
\newcommand{\descra}[1]{ & \hspace{35mm} \Rightarrow     \hspace{4mm} \{ \mathrm{#1} \}}
\newcommand{\descla}[1]{ & \hspace{35mm} \Leftarrow      \hspace{4mm} \{ \mathrm{#1} \}}
\newcommand{\desclra}[1]{& \hspace{35mm} \Leftrightarrow \hspace{4mm} \{ \mathrm{#1} \}}

\newcommand\lub[1]{\sqcup_{#1}}
\newcommand\defof[1]{definition \, of \, #1}

\newcommand\w[0]{\,\,}
\newcommand\eq[0]{=}

\begin{document}

\chapter{Proof Methods}

\noindent
\input{fixpoint}

\bibliographystyle{apalikeurl}
\bibliography{masterbib}


\end{document}

%\begin{comment}

%% Title ----------------------------------------------------------------------
\title{Proving Equational Haskell Properties Using ATPs}
\author{Dan Ros√©n}
\maketitle

%% Abstract -------------------------------------------------------------------

\newpage
\abstract{
In this work we prove a lot of nice equational Haskell properties by
a first order logic translation and using automated theorem provers.
The results are astounding, writing correct Haskell is nowadays a
breeze.
}

%% Acknowledgements -----------------------------------------------------------

\newpage
\pagestyle{empty}
\section*{Acknowledgments}
\vspace{5mm}
ACK, ACK, ACK, ACK, ACK, ACK, NAK

%% Table of Contents ----------------------------------------------------------

\newpage
\tableofcontents
\addtocontents{toc}{\protect\thispagestyle{empty}}

\newpage
\setcounter{page}{1}

\chapter{Introduction}

Induction and Haskell

Infinite values in Haskell are commonplace, but why care about partial
values? They are still present because of non-terminating programs,
calls to the error function and pattern-match
failures \cite{chasingbot}.

\section{Outline}

Explain the outline of the report

\chapter{Background - to me merged}

This work's main areas, Haskell, FOL, ATPs and some basic DT.

\section{Haskell}

Describe some of the features of Haskell, types, lazy evaluation,
bottoms, pattern-matching, data types, type classes.

Haskell is declarative and side-effect free which makes it easy
to model in logic in comparison to imperative effectful programming languages.

\section{First Order Logic}

Connectives, quantifiers, predicates, functions and constants.
Derivation rules and models.

\section{FOL and Automated Theorem Provers}

Use derivations or models to deduce absurdity.

\section{Induction}

Some background of induction and how it is present in well-known
theories like PA, ZFC, MLTT and CoC.

PA which only concerns natural numbers has a small vocabulary
consisting only of the constant $0$, the unary successor function $s$,
and binary plus and multiplication.
Here the induction schema from looks like this:

\note{One could also be explicit about the free variables in $P$}
\begin{mathpar}
  \inferrule*
     {
       \overbrace{P(0)}^{\mathrm{base}}
       \\
       \overbrace{
           \fa{x}
                 \underbrace{P(x)}_{\mathrm{hypothesis}}
              \rightarrow
                 \underbrace{P(s(x))}_{\mathrm{conclusion}}
       }^{\mathrm{step}}
     }
     { \fa{x} P(x) }
\end{mathpar}

This is a axioms schema since it is not possible to quantify over the
predicate $P$ in FOL. Rather, it is a infinite set of axioms, one for
each (well-formed) formula instantiated in place for $P$. Generally,
ATPs do not instantiate schemas themselves but it has to be done
manually, with an appropriate formula for $P$.

\section{Domain Theory}

CPOs, monotonicity, continuity and admissible predicates.

\section{Related Work}

\note{Related work in background or in discussion? Would be nice to
  have it after the technical part to be able to compare different
  approaches.}
Isabel, Sledgehammer, Rippling and other techniques
(Productive Use of Failure)

Other proof assistants as Coq

Agda and dependent types, Agda and ATPs by Peter, Bove, Sicard
\cite{agdaatp} and Dependently Typed Programming Based on ATPs

Zeno

Co-recursive techniques \cite{corecursive}, Hinze's papers, Generic
Approximation lemma, or have this in other chapters

%% Technical Part --------------------------------------------------------------

\input{translation}

\input{proofs}

%% End of Technical Part ------------------------------------------------------


\chapter{Discussion}

\section{Results}

Test suite

\section{Future work}

QuickSpec (IsaCosy)

Finite/Total domains and what is a terminating function, anyway?
Predicates, functions or fast and loose reasoning \cite{fastandloose}

Lemmas

Implications

Finite fixed point induction on terminating functions

Fix-point induction with id on variables

Recursion-induction

Fix-point induction (and approximation lemma) induction depth machines

Cover a larger part of Haskell (type classes, do-notation, list
comprehensions, records, pattern bindings)

Min-predicate for finite models and quicker proof searches

Since we will need to prove termination for functions, how would one
prove non-termination (for some inputs)? Then we could get more
completeness: this function with these inputs would be $\bot$.

\section{Conclusion}

%% References -----------------------------------------------------------------

\bibliographystyle{apalikeurl}
\bibliography{masterbib}
\end{document}

\end{comment}