\section{Fixed point induction}

Fixed point induction is an early example of a technique
from domain theory, attributed to Scott and de Bakker,
\note{citation needed, there is a book called Mathematical Theory of
  Program Correctness by Jaco de Bakker that could be appropriate if found}
and sometimes called Scott induction or computational induction.
\cite{domains} The least fixed point for a function can be found in
Haskell with the function \hs{fix}, which can simply be defined as:

\begin{verbatim}
fix :: (a -> a) -> a
fix f = f (fix f)
\end{verbatim}

Any self-recursive function can be rewritten in terms of
\hs{fix}. Recall the \hs{Prelude} function \hs{repeat}, which makes an
infinite list of the same element \hs{repeat x = x : repeat}. Its
transformation to \hs{fix}-style is this:

\begin{verbatim}
repeat x = fix r
  where r i = x : i
\end{verbatim}

Computing \hs{repeat x}, we get the following unfolds:
\begin{equation*}
  \hs{repeat x}
= \hs{fix r}
= \hs{x:fix r}
= \hs{x:x:fix r}
= \hs{x:x:x:fix r}
  \cdots
\end{equation*}
So \hs{fix (x:)} is the infinite list of \hs{x}. The translation of a
self-recursive function to be defined in terms of \hs{fix} is
mechanical. Assume $f$ is defined with arguments $\overline{x}$ and
has a body $e$ that uses both itself and its arguments, let us write
this as $e(f,\overline{x})$. Then the translation is this:

\begin{equation*}
f \w \overline{x} \eq e(f,\overline{x})
\w \Leftrightarrow \w
f \eq \hs{fix}(\lambda f' \w \overline{x} \w \rightarrow \w e(f',\overline{x}))
\end{equation*}

Fixpoint induction proves properties about a function written in terms
of \hs{fix}, and its inference rule is this:

\begin{mathpar}
  \inferrule*
     {
       P(\bot)
       \\
       P(x) \rightarrow P(f \w x)
       \\
       P \w \mathrm{admissible}
     }
     { P(\fn{fix} f) }
\end{mathpar}

Here it is important that $P$ is \emph{admissible} or
$\omega$-\emph{inductive}, meaning that for all $\sqsubseteq$-chains
of countable length (therefore the $\omega$), if the property holds
for all elements in the chain it must necessary hold for its limit.
Since we are currently only interested about equalities, we can relax:
universally quantified equalities of continuous functions are examples
of admissible predicates. Furthermore all functions we can define in
Haskell are continuous.

An interesting property of fixed point induction is that it does not
care about types: indeed, it works in an untyped setting. In addition,
it can exploit strange recursive structures of the function. A caveat
is that it can only prove properties that must hold for infinite and
partial values.

\subsection{Example: map-iterate}

The two Haskell functions \hs{map} and \hs{iterate} are related in a
simple way, namely

\begin{equation*}
\faa{f}{x} \hs{map} \w f \w (\hs{iterate} \w f \w x) \eq
           \hs{iterate} \w f \w (f \w x)
\end{equation*}

With their standard definitions

\begin{verbatim}
map :: (a -> b) -> [a] -> [b]    iterate :: (a -> a) -> a -> [a]
map f (x:xs) = f x : map f xs    iterate f x = x : iterate f (f x)
map f [] = []
\end{verbatim}

The behavior of \hs{map} is to apply a function to every element of a
list, and \hs{iterate} makes an infinite list from a seed, by repeated
application of a function. This can easily be proved by fixpoint
induction on \hs{iterate}. First, we rewrite this function in terms of
\hs{fix}:

\begin{verbatim}
iterate = fix iter
iter i f x = x : i f (f x)
\end{verbatim}

The predicate $P$ from fixpoint induction is $P(g) \w \Leftrightarrow
\w \faa{f}{x} \hs{map} \w f \w (g \w f \w x) \eq g \w f \w (f \w x) $. If we
prove the base case and step case we can then conclude
$P(\hs{fix iter})$, and that is by definition $P(\hs{iterate})$.

The base case is $P(\bot)$. Since \hs{map} is strict in its second
argument, it is both the left side and right side evaluate to $\bot$.
The for the step case we have to show
$P(\hs{i}) \rightarrow P(\hs{iter i})$. We start from the induction
hypothesis and work towards the goal as follows:

\begin{align*}
\w \faa{f}{x} \hs{map} \w f \w (\hs{i} \w f \w x) & \eq \hs{i} \w f \w (f \w x) \\
\descra{generalizing \w \mathit{x} \w to \w \mathit{f \w x}} \\
\w \faa{f}{x} \hs{map} \w f \w (\hs{i} \w f \w (f \w x)) & \eq \hs{i} \w f \w (f \w (f \w x)) \\
\descra{substitutivity} \\
\w \faa{f}{x} f \w x \hs{:} \hs{map} \w f \w (\hs{i} \w f \w (f \w x)) & \eq f \w x \hs{:} \hs{i} \w f \w (f \w (f \w x)) \\
\desclra{definition \w of \w \hs{map}} \\
\w \faa{f}{x} \hs{map} \w f \w (x \hs{:} \hs{i} \w f \w (f \w x)) & \eq f \w x \hs{:} \hs{i} \w f \w (f \w (f \w x)) \\
\desclra{definition \w of \w \hs{iter}} \\
\w \faa{f}{x} \hs{map} \w f \w (\hs{iter} \w \hs{i} \w f \w x) & \eq \hs{iter} \w \hs{i} \w f \w (f \w x) \\
\end{align*}

As discussed earlier, the $P$ used is admissible since it is an
universally quantified equality. Hence, fixpoint induction gives us the
\hs{map}-\hs{iterate} property.

\subsection{Erroneous use of fixed point induction}

To illustrate why it is important that the property $P$ is admissible,
consider the predicate P to be “is not infinite”, and then you can
prove for a lot of functions that they return finite objects. For
instance, define this function:

\begin{verbatim}
listrec :: ([a] -> [a]) -> [a] -> [a]
listrec i [] = []
listrec i (x:xs) = x : i xs
\end{verbatim}

Then define
$P(f) \Leftrightarrow \fa{x} f(x) \w \mathrm{is \w not \w infinite}$,
and proceed to prove $P(\hs{fix listrec})$ by fixed point induction. The
base case $P(\bot)$ succeeds, since $\bot$ is not infinite, and if we
assume $P(\hs{i})$, we have no problem proving $P(\hs{listrec i})$.
Hence $P(\hs{fix listrec})$, and since \hs{fix listrec} is essentially
a linear identity function on lists, we have ``proved'' that all lists
are finite (but possibly partial).

The error is of course that $P$ is not
admissible. Indeed, for the sequence
\begin{equation*}
\bot \sqsubseteq
\hs{0:}\bot \sqsubseteq
\hs{0:1:}\bot \sqsubseteq
\hs{0:1:2:}\bot \sqsubseteq
\cdots
\end{equation*}
$P$ holds for all elements but $P$ does not hold for its limit \hs{[0..]}.

\subsection{Uncategorized / old}

A simple way of defining a fixed point combinator in Haskell is
\begin{verbatim}
fix :: (a -> a) -> a
fix f = f (fix f)
\end{verbatim}

The translation from a function written with explicit recursion to a
style with \hs{fix} is mechanical. Consider \hs{iterate}

\begin{verbatim}
iterate f x = x : iterate f (f x)
\end{verbatim}

Each occurrence of the same function is copied with a new definition,
here \hs{iterateStep}, with an additional argument (here \hs{i}) which
replaces the recursive call.

\begin{verbatim}
iterate = fix iterateStep
iterateStep i f x = x : i f (f x)
\end{verbatim}

Now,
\hs{fix iterateStep} =
\hs{iterateStep (fix iterateStep}) =
\hs{iterateStep (iterateStep (fix iterateStep))} = ...
\hs{iterateStep (iterateStep (... (iterateStep (fix iterateStep))
  ...))}, which allows arbitrary unrolling of the definition, making it
  equivalent to \hs{iterate} above.

\subsection{Implementation}

To prove something regarding a function $f$ defined abstractly with
arguments $\overline{x}$ and body $e(\overline{x},f)$ as

\begin{equation*}
f \, \overline{x} = e(\overline{x},f)
\end{equation*}



We introduce two new constants, $\tofix{f}$ and $\unfix{f}$ as this:

\begin{equation*}
\tofix{f} \, \overline{x} = e(\overline{x},\unfix{f})
\end{equation*}

\note{Some side-by side reasoning how it looks with these definitions
  and the normal definitions of fixpoint induction}
The fixpoint schema now becomes:

\begin{mathpar}
  \inferrule*
     {
       P(\bot)
       \\
       P(\unfix{f}) \rightarrow P(\tofix{f})
       \\
       P \, \mathrm{admissible}
     }
     { P(f) }
\end{mathpar}


This also works for several functions at the same time, possibly
mutually recursive:

\begin{mathpar}
  \inferrule*
     {
       P(\bot,\bot)
       \\
       P(\unfix{f},\unfix{g}) \rightarrow P(\tofix{f},\tofix{g})
       \\
       P \, \mathrm{admissible}
     }
     { P(f,g) }
\end{mathpar}

\subsection{Natural Selection}

Given a property like list concatenation as above
\note{examples are not set in stone so this may change}
it is actually not possible to show the property with fixed point
induction on all four occurrences of \hs{++}. As if you would do
structural induction on this proof, you will see that the both in the
left hand side are normalized, and the first on the right hand
side. These are the functions you will want to do fixpoint induction
on. See illustration with $\mathbf{app}$ on the locations suspect for
fixpoint induction and $app$ for no change:

\begin{equation*}
\faaa{xs}{ys}{zs} \mathbf{app}(app(xs,ys),zs)
               =  \mathbf{app}(xs,app(ys,zs))
\end{equation*}
\note{I cannot prove the $\mathbf{[]}$ case for this}

The approach taken here is to try fixed point induction on all the
subsets of the recursive functions mentioned in the property.


