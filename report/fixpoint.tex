\section{Fixed point induction}

Fixed point induction is an early example of a technique
from domain theory, attributed to Scott and de Bakker,
\note{citation needed, there is a book called Mathematical Theory of
  Program Correctness by Jaco de Bakker that could be appropriate if found}
and sometimes called Scott induction or computational induction.
\cite{domains} The least fixed point for a function can be found in
Haskell with the function \hs{fix}, which can simply be defined as:

\begin{verbatim}
fix :: (a -> a) -> a
fix f = f (fix f)
\end{verbatim}

Any self-recursive function can be rewritten in terms of
\hs{fix}. Recall the \hs{Prelude} function \hs{repeat}, which makes an
infinite list of the same element \hs{repeat x = x : repeat}. Its
transformation to \hs{fix}-style is this:

\begin{verbatim}
repeat x = fix r
  where r i = x : i
\end{verbatim}

Computing \hs{repeat x}, we get the following unfolds:
\begin{equation*}
  \hs{repeat x}
= \hs{fix r}
= \hs{x:fix r}
= \hs{x:x:fix r}
= \hs{x:x:x:fix r}
  \cdots
\end{equation*}
So \hs{fix (x:)} is the infinite list of \hs{x}. The translation of a
self-recursive function to be defined in terms of \hs{fix} is
mechanical. Assume $f$ is defined with arguments $\overline{x}$ and
has a body $e$ that uses both itself and its arguments, let us write
this as $e(f,\overline{x})$. Then the translation is this:

\begin{equation*}
f \w \overline{x} \eq e(f,\overline{x})
\w \Leftrightarrow \w
f \eq \hs{fix}(\lambda f' \w \overline{x} \w \rightarrow \w e(f',\overline{x}))
\end{equation*}

Fixpoint induction proves properties about a function written in terms
of \hs{fix}, and its inference rule is this:

\begin{mathpar}
  \inferrule*
     {
       P(\bot)
       \\
       P(x) \rightarrow P(f \w x)
       \\
       P \w \mathrm{admissible}
     }
     { P(\fn{fix} f) }
\end{mathpar}

Here it is important that $P$ is \emph{admissible} or
$\omega$-\emph{inductive}, meaning that for all $\sqsubseteq$-chains
of countable length (therefore the $\omega$), if the property holds
for all elements in the chain it must necessary hold for its limit.
Since we are currently only interested about equalities, we can relax:
universally quantified equalities of continuous functions are examples
of admissible predicates. Furthermore all functions we can define in
Haskell are continuous.

An interesting property of fixed point induction is that it does not
care about types: indeed, it works in an untyped setting. In addition,
it can exploit strange recursive structures of the function. A caveat
is that it can only prove properties that must hold for infinite and
partial values.

\note{There are also a bunch of proofs available to show here: which
  are necessary here?  We have that $fix_f \bot = \lub{n}(f^n \bot)$
  and that $fix_f$ is the least prefixed-point of $x = f x$, if there
  is another one $\theta$, then $fix_f \sqsubseteq \theta$ (by
  induction). Futhermore, it is probably appropriate to elaborate why
  \hs{fix f = f (fix f)} is equal to $\lub{n}(f^n \bot)$ (even though
  it is obvious!) Page 5 \cite{domains}.  }
The proof that fixed point induction relies on the fact that
$\lub{n}(f^n \w \bot) \eq \hs{fix} \w f$, where $f^n$ is $n$
self-applications of $f$. This is true since \hs{fix} is defined as
$f$ self-applied to it self. Apart from this, the proof only uses
induction over natural numbers and that $\f^0 \w \bot \eq \bot$, and
it is of course important that $P$ is admissible. See proof below:

\begin{align*}
P(\bot) & \wedge \fa{x} P(x) \rightarrow P(f x) \\
\desclra{\mathit{f^0 \w \bot \eq \bot}} \\
P(f^0 \w \bot) & \wedge \fa{x} P(x) \rightarrow P(f x) \\
\descra{quantfying} \\
P(f^0 \w \bot) & \wedge \fa{n} P(f^n \w \bot) \rightarrow P(f^{n+1} \w \bot) \\
\desclra{induction} \\
\fa{n} & P(f^n \w \bot) \\
\desclra{\mathit{P} \w admissible} \\
& P(\lub{n}(f^n \w \bot)) \\
\desclra{definition \w of \w \hs{fix}} \\
& P(\hs{fix} \w f) \\
\end{align*}


\subsection{Example: map-iterate}

For properties that do not have any arguments with a concrete type,
structural induction is not applicable. The Haskell function
\hs{iterate} is a that makes an infinite list from a seed, by repeated
application of a function, i.e \hs{iterate f x} is the list
 \hs{x:f x:f (f x):}$\cdots$. It is related to Haskell function
 \hs{map} in the map-iterate property, stated as follows:

\begin{equation*}
\faa{f}{x} \hs{map} \w f \w (\hs{iterate} \w f \w x) \eq
           \hs{iterate} \w f \w (f \w x)
\end{equation*}

With their standard definitions

\begin{verbatim}
map :: (a -> b) -> [a] -> [b]    iterate :: (a -> a) -> a -> [a]
map f (x:xs) = f x : map f xs    iterate f x = x : iterate f (f x)
map f [] = []
\end{verbatim}

The behavior of \hs{map} is to apply a function to every element of a
list. We see that we cannot use structural induction here, since both
$f$ and $x$ are abstract, but this can be proved by fixpoint induction
on \hs{iterate}. First, we rewrite this function in terms of \hs{fix}:

\begin{verbatim}
iterate = fix iter
iter i f x = x : i f (f x)
\end{verbatim}

The predicate $P$ from fixpoint induction is $P(g) \w \Leftrightarrow
\w \faa{f}{x} \hs{map} \w f \w (g \w f \w x) \eq g \w f \w (f \w x) $. If we
prove the base case and step case we can then conclude
$P(\hs{fix iter})$, and that is by definition $P(\hs{iterate})$.

The base case is $P(\bot)$. Since \hs{map} is strict in its second
argument, it is both the left side and right side evaluate to $\bot$.
The for the step case we have to show
$P(\hs{i}) \rightarrow P(\hs{iter i})$. We start from the induction
hypothesis and work towards the goal as follows:

\begin{align*}
\w \faa{f}{x} \hs{map} \w f \w (\hs{i} \w f \w x) & \eq \hs{i} \w f \w (f \w x) \\
\descra{generalizing \w \mathit{x} \w to \w \mathit{f \w x}} \\
\w \faa{f}{x} \hs{map} \w f \w (\hs{i} \w f \w (f \w x)) & \eq \hs{i} \w f \w (f \w (f \w x)) \\
\descra{substitutivity} \\
\w \faa{f}{x} f \w x \hs{:} \hs{map} \w f \w (\hs{i} \w f \w (f \w x)) & \eq f \w x \hs{:} \hs{i} \w f \w (f \w (f \w x)) \\
\desclra{definition \w of \w \hs{map}} \\
\w \faa{f}{x} \hs{map} \w f \w (x \hs{:} \hs{i} \w f \w (f \w x)) & \eq f \w x \hs{:} \hs{i} \w f \w (f \w (f \w x)) \\
\desclra{definition \w of \w \hs{iter}} \\
\w \faa{f}{x} \hs{map} \w f \w (\hs{iter} \w \hs{i} \w f \w x) & \eq \hs{iter} \w \hs{i} \w f \w (f \w x) \\
\end{align*}

As discussed earlier, the $P$ used is admissible since it is an
universally quantified equality. Hence, fixpoint induction gives us the
\hs{map}-\hs{iterate} property.

\subsection{Erroneous use of fixed point induction}

To illustrate why it is important that the property $P$ is admissible,
consider the predicate P to be “is not infinite”, and then you can
prove for a lot of functions that they return finite objects. For
instance, define this function:

\begin{verbatim}
listrec :: ([a] -> [a]) -> [a] -> [a]
listrec i [] = []
listrec i (x:xs) = x : i xs
\end{verbatim}

Then define
$P(f) \Leftrightarrow \fa{x} f(x) \w \mathrm{is \w not \w infinite}$,
and proceed to prove $P(\hs{fix listrec})$ by fixed point induction. The
base case $P(\bot)$ succeeds, since $\bot$ is not infinite, and if we
assume $P(\hs{i})$, we have no problem proving $P(\hs{listrec i})$.
Hence $P(\hs{fix listrec})$, and since \hs{fix listrec} is essentially
a linear identity function on lists, we have ``proved'' that all lists
are finite (but possibly partial).

The error is of course that $P$ is not
admissible. Indeed, for the sequence
\begin{equation*}
\bot \sqsubseteq
\hs{0:}\bot \sqsubseteq
\hs{0:1:}\bot \sqsubseteq
\hs{0:1:2:}\bot \sqsubseteq
\cdots
\end{equation*}
$P$ holds for all elements but $P$ does not hold for its limit \hs{[0..]}.

\subsection{Mutually recursive functions}

You can also mechanically transform mutually recursive functions to be
defined in terms of \hs{fix}. The functions \hs{even} and \hs{odd}
defined below, which determines if a \hs{Nat} is even, and odd,
respectively, are straightforwardly written by mutual recursion:

\begin{verbatim}
even :: Nat -> Bool           odd :: Nat -> Bool
even Z     = True             odd Z     = False
even (S x) = odd x            odd (S x) = even x
\end{verbatim}

To write these functions in terms of fix, as an additional argument,
the take a tuple of ``non-recursive'' copies of themselves.

\begin{verbatim}
evenToFix :: (Nat -> Bool,Nat -> Bool) -> Nat -> Bool
evenToFix (evenUnFix,oddUnFix) Z     = True
evenToFix (evenUnFix,oddUnFix) (S x) = oddUnFix x

oddToFix :: (Nat -> Bool,Nat -> Bool) -> Nat -> Bool
oddToFix (evenUnFix,oddUnFix) Z     = True
oddToFix (evenUnFix,oddUnFix) (S x) = evenUnFix x
\end{verbatim}

Here the prefix \hs{ToFix} means that it is a function subject to be
\hs{fix}-ed, and \hs{UnFix} means that it is the ``non-recursive''
function. The functions above can now be \hs{fix}-ed by giving the
tuple as an argument to both of them:

\begin{verbatim}
even',odd' :: Nat -> Bool
(even',odd') = fix (\t -> (evenToFix t,oddToFix t))
\end{verbatim}

This encoding makes \hs{even'} denotationally equal to \hs{even} and
the same relation hols for \hs{odd'} and \hs{odd}.

\subsection{Implementation}

The mechanical translations introduced above for self-recursive
functions and mutually recursive functions makes a new function with
an additional argument, the ``non-recursive'' version of itself. By
the translation to FOL that is used, this would introduce a new
argument as a ``function pointer'' and introduce uses of $\app$, which
seems to confuse at least both eprover and SPASS. Another approach
which avoids introducing these function pointers, and an additional
argument to every function is to replace a function $f$ defined
abstractly with arguments $\overline{x}$ and body $e(\overline{x},f)$
as

\begin{equation*}
f \, \overline{x} = e(\overline{x},f)
\end{equation*}

We introduce two new constants, $\tofix{f}$ and $\unfix{f}$ as this:

\begin{equation*}
\tofix{f} \, \overline{x} = e(\overline{x},\unfix{f})
\end{equation*}

\note{Maybe some side-by side reasoning how it looks with these definitions
  and the normal definitions of fixpoint induction}
The fixpoint schema now becomes:

\begin{mathpar}
  \inferrule*
     {
       P(\bot)
       \\
       P(\unfix{f}) \rightarrow P(\tofix{f})
       \\
       P \, \mathrm{admissible}
     }
     { P(f) }
\end{mathpar}

This also works for several functions at the same time, possibly
mutually recursive:

\begin{mathpar}
  \inferrule*
     {
       P(\bot,\bot)
       \\
       P(\unfix{f},\unfix{g}) \rightarrow P(\tofix{f},\tofix{g})
       \\
       P \, \mathrm{admissible}
     }
     { P(f,g) }
\end{mathpar}

This translation needs to be carried out with some care, since for $f
\, \overline{x} = e(\overline{x},f)$, it is also possible that $f$ is
called in bodies of other functions. These are of two kinds: either
this function is also called from $f$, making it recursive, or another
function which is not called from $f$, but makes use of $f$
anyway. The first example, with a recursive call, the body needs to be
edited so $f$ becomes translated (to $\bot$, $\unfix{f}$ or
$\tofix{f}$, and the second case should use the original $f$. The
transitive clousure of the call graph is calculated, and every
appropriate calls of $f$ are replaced.


\subsection{Natural Selection}

Given a property like list concatenation as above
\note{examples are not set in stone so this may change}
it is actually not possible to show the property with fixed point
induction on all four occurrences of \hs{++}. As if you would do
structural induction on this proof, you will see that the both in the
left hand side are normalized, and the first on the right hand
side. These are the functions you will want to do fixpoint induction
on. See illustration with $\mathbf{app}$ on the locations suspect for
fixpoint induction and $app$ for no change:

\begin{equation*}
\faaa{xs}{ys}{zs} \mathbf{app}(app(xs,ys),zs)
               =  \mathbf{app}(xs,app(ys,zs))
\end{equation*}

The approach taken here is to try fixed point induction on all the
subsets of the recursive functions mentioned in the property.


