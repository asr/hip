
Imagine you find the following data type for binary trees
\citep{grafting} and an implementation of the \hs{Monad} type class
\citep{mtl} for it:


\begin{code}
data Tree a = Fork (Tree a) (Tree a) | Leaf a

return :: a -> Tree a
return = Leaf

(>>=) :: Tree a -> (a -> Tree b) -> Tree b
Fork u v >>= f = Fork (u >>= f) (v >>= f)
Leaf x   >>= f = f x
\end{code}

\noindent
You wonder if the elegant simplicity of bind possibly could obey the
three monad laws as stated by \cite{essenceoffp}. Haskell is
celebrated for being a language easy to reason about, and referential
transparency makes equational reasoning easy and sound, but proving
the monad laws by hand can be tiresome. This is a situation where our
tool can help: write down the equations in a similar style as
properties in QuickCheck \citep{quickcheck}. Run the tool on the
source file and after a few seconds you get this result\footnote{The
  presentation format is slightly rewritten for your viewing
  pleasure.}:

\begin{code}
Theorems (3/3):
  prop_return_right: t >>= return == t
    by structural induction on t and by approximation lemma

  prop_return_left: return x >>= f == f x
    by definitional equality and by approximation lemma

  prop_assoc: (t >>= f) >>= g == t >>= (\x -> f x >>= g)
    by structural induction on t and by fixed point induction on (>>=)
\end{code}

\noindent
What is going on behind the scenes to prove this?  There are three
main parts:
\begin{enumerate}
\item translation from Haskell to first order logic,
\item instantiating the properties with different induction
  techniques, and
\item running automated theorem provers on the generated theories.
\end{enumerate}
The rest of this thesis describes these different parts.

\section{Aim}

The aim of this thesis is to develop a tool able to do automated
proving of Haskell properties. This should be realized by means of
different induction techniques, a translation to first order logic and
invocations to automated theorem provers. The tool should be able to
reason and prove properties about lazy data structures, higher order
functions and infinite and partial values. The project is restricted
to equational properties to keep it tractable, and equality should
coincide with equality in first order logic. This means that mean that
two values are equal if they are created by the same constructor, and
the arguments to the constructors are all equal.

\section{Prerequisites}

To read this thesis, the reader should have at least brief knowledge
of Haskell. An introduction is given by \cite{lyah}. Some familiarity
of model theory and proof deduction in first order logic is
beneficial, as well as a grasp of proofs by induction. At least a
shallow apprehension of using automated theorem provers is assumed.












































\begin{comment}
INTRODUCTION - State your thesis and the purpose of your research
paper clearly. What is the chief reason you are writing the paper?
State also how you plan to approach your topic. Is this a factual
report, a book review, a comparison, or an analysis of a problem?
Explain briefly the major points you plan to cover in your paper and
why readers should be interested in your topic.
\end{comment}



\begin{comment}

%% Shit the same, just write something

%In this thesis we introduce a new way to automatically prove
%properties of Haskell programs with the aid of automated theorem
%provers (ATPs).

Haskell is celebrated for being a language easy to reason about.
Referential transparency makes equational reasoning easy and
sound. The testing tool QuickCheck \citep{quickcheck} has influenced
programmers to state properties about their program's functions. This
thesis introduces an automated way to prove properties with the aid of
automated theorem provers, by means of a translation from Haskell to
First Order Logic. This compilation can handle the important concepts
of higher order functions and lambda abstraction, and can deal with
infinite values as well as partial values from pattern match failures
or partial functions.

We currently handle universally quantified equational properties. From
the programmers perspective, they can be entered in the source code
like this:

\begin{code}
prop_filter_append :: (a -> Bool) -> [a] -> [a] -> Prop [a]
prop_filter_append p xs ys = filter p (xs ++ ys) =:= filter p xs ++ filter p ys
\end{code}

\noindent
Every function and data definition needs to be translated into a
theory in first order logic which we can call $\mathcal{T}$. The
property above then corresponds to this proving this:

\begin{equation*}
\mathcal{T} \vdash \faaa{p}{xs}{ys} \fn{filter}(p,xs \,\append\, ys) = \fn{filter}(p,xs) \,\append\, \fn{filter}(p,ys)
\end{equation*}

\noindent
By writing $\fn{filter}$ and $\append$, it is emphasised that these
are the translations of \hs{filter} and \hs{++} axiomatised in
$\mathcal{T}$. To proceed to prove a property like this different
proving techniques for functional programs are automatically
tested. These can deal with reasoning about programs with both finite
arguments and infinite.

There are many examples of equality properties.  Verifying that an
efficient and a naive implementation solution coincide. Proving
fundamental laws that your functions should hold, be it the axioms of
a ring, or more specifically, idempotency of sorting or involution of
reversing, or relating different functions in terms of homomorphisms
or more complicated relations. The rich plethora of type classes in
Haskell have many stipulated equational laws.

Equality is between Haskell values, and not the different equalities
defined by the \hs{Eq} type class. It is however possible to express
such properties as well. One example is the relation between
\hs{lookup} and \hs{adjust} from \hs{Data.Map} in the containers
package:

\begin{code}
prop_lookup_alter :: (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
prop_lookup_alter f k m = lookup k (alter f k m) == f (lookup k m) =:= True
\end{code}


\end{comment}

\begin{comment}

Why is equality important? There are many reasons why you would want
to know why two Haskell expressions are equal. You might have a naive
way of implementing an algorithm, and an efficient way, and you want
to know that those two implementations behave equally. Your functions
may be a familiar algebraic structure: monoid, group, ring, lattice
and so on, and you want to know that your implementation satisfies all
laws, or your functions may not have such a rich structure but still
have a lot of properties, like idempotency: sorting twice is the same
as sorting one, involution: reversing twice is the same as doing
nothing (but only for finite lists!). Functions could also be
homomorphisms over structures:
\hs{length (xs ++ ys)}$\eq$\hs{length xs + length xs} is an example of
a monoid homomorphism between list concatenation and addition. Haskell
is also known for its type classes like Functor, Applicative and
Monad, and all instances of these should satisfy certain equational
laws.

What is equality? In the general context, a binary relation is an
equivalence relation if it is reflexive ($\fa{x} x \eq x$), symmetric
($\faa{x}{y} x \eq y \rightarrow y \eq x$) and transitive
($\faaa{x}{y}{z} x \eq y \wedge y \eq z \rightarrow x \eq z$). In
Haskell, it is indeed so that every data type can have its own
instance of the \hs{Eq} type class, gives a computable function given
two values of the type and determines if they are equal, the result
given as true or false in a \hs{Bool}. In this project we have made
the simplification that two Haskell values are equal if they have
exactly the same structure: the same constructor at every depth. We
also regard the undefined value $\bot$ as a constructor, so
$\hs{x:}\bot$ is not equal to $\hs{x:[]}$. If the concept of $\bot$ is
unfamiliar to you, do not fear: it will be explained in great
detail. The reason for this simplification is that it will coincide
exactly with the equality in first order logic and allows us to use its
substitution.
\note{Congruence relations!}

\end{comment}