{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module Language.HFOL.ToTPTPMonad where

import Language.HFOL.Core
import Language.HFOL.RemoveOverlap
import qualified Language.TPTP as T
import Language.TPTP
import Language.TPTP.Pretty

import Control.Applicative
import Control.Monad
import Control.Monad.State
import Control.Monad.Reader

import Data.Maybe

import Data.Map (Map)
import qualified Data.Map as M
import Data.Set (Set)
import qualified Data.Set as S

newtype ToTPTP a = MkToTPTP { runToTPTP :: ReaderT Env (State St) a }
  deriving (Functor,Applicative,Monad,MonadState St,MonadReader Env)

data Env = Env { arities   :: Map Name Int
                 -- ^ Arity of functions and constructors
               , boundVars :: Map Name (Either FunName VarName)
                 -- ^ TPTP name of functions and constructors and quantified variables)
               , conProj   :: Map Name [Name]
                 -- ^ Projection functions for constructors
               , conFam    :: Map Name [Name]
                 -- ^ The other constructors for a given constructor
               }

data St = St { usedFnPtrs :: Set Name
               -- ^ Which functions we need to produce ptr conversions for
             }

lookupVar :: Name -> ToTPTP (Either FunName VarName)
lookupVar n = asks (fromMaybe (error $ "lookupVar, unbound: " ++ n)
                   . M.lookup n . boundVars)

lookupArity :: Name -> ToTPTP Int
lookupArity n = asks (fromMaybe (error $ "lookupArity, unbound: " ++ n)
                   . M.lookup n . arities)

bindVar :: Name -> VarName -> ToTPTP a -> ToTPTP a
bindVar n v = local $ \e -> e { boundVars = M.insert n (Right v) (boundVars e) }

bindVars :: [Name] -> [VarName] -> ToTPTP a -> ToTPTP a
bindVars ns vs = local $ \e -> e { boundVars =
                                      foldr (\(n,v) -> M.insert n (Right v))
                                            (boundVars e)
                                            (zip ns vs)
                                 }

-- | Make a pointer name of a function name
makePtrName :: Name -> Name
makePtrName n = n ++ "_ptr"

makeFunPtrName :: FunName -> FunName
makeFunPtrName = FunName . makePtrName . funName

-- | Add a function's arity and its FunName, autogenerated
addFun :: Name -> Int -> Env -> Env
addFun n args e = e { arities   = M.insert n args (arities e)
                    , boundVars = M.insert n (Left (FunName n)) (boundVars e)
                    }

-- | Add a datatype's constructor given the arities
--   Projections  are also generated
addCons :: [(Name,Int)] -> Env -> Env
addCons cs e = flip (foldr (uncurry addFun)) cs
             $ flip (foldr (uncurry addProj)) cs
             $ e { conFam = foldr (\c -> M.insert c cs') (conFam e) cs' }
  where
    cs' = map fst cs
    -- | Automatically make projections for a constructor of a given arity
    addProj :: Name -> Int -> Env -> Env
    addProj c n e = e { conProj = M.insert c [ "proj" ++ show x ++ c
                                             | x <- [0..n-1] ]
                                             (conProj e) }

-- Mark a pointer as used
useFnPtr :: Name -> ToTPTP ()
useFnPtr fn = modify $ \s -> s { usedFnPtrs = S.insert fn (usedFnPtrs s) }

-- | Make new variable names
makeVarNames n = [ T.VarName ('X' : show x) | x <- [0..n-1] ]

-- | All FOL declarations from an environment and state
envStDecls :: Env -> St -> [T.Decl]
envStDecls e s = projDecls (conProj e) ++ ptrDecls (arities e) (usedFnPtrs s)

-- | Make projection declarations
projDecls :: Map Name [Name] -> [T.Decl]
projDecls = concatMap (uncurry mkDecl) . M.toList
  where
    mkDecl :: Name -> [Name] -> [T.Decl]
    mkDecl c ps = zipWith (\x p -> T.Axiom ("axiom" ++ p)
                                 $ T.Forall xs $ T.EqOp
                                      (T.Fun (T.FunName p)
                                         [T.Fun (T.FunName c) (map T.Var xs)])
                                      (T.:==)
                                      (T.Var x))
                          xs ps
      where arity = length ps
            xs    = makeVarNames arity

appFold :: T.Term -> [T.Term] -> T.Term
appFold = foldl (\f x -> T.Fun (T.FunName "app") [f,x])

-- | Make pointer declarations
ptrDecls :: Map Name Int -> Set Name -> [T.Decl]
ptrDecls arities = map mkDecl . S.toList
  where
    mkDecl fn = T.Axiom ("ptr" ++ fn)
              $ T.Forall xs
                $ T.EqOp (appFold (T.Var (T.VarName (makePtrName fn)))
                                   (map T.Var xs))
                         (T.:==)
                         (T.Fun (T.FunName fn) (map T.Var xs))
      where arity = arities M.! fn
            xs    = makeVarNames arity

emptyEnv = Env M.empty M.empty M.empty M.empty

emptySt = St S.empty
